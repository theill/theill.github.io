<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://www.monmouth.com/~wstreett/lex-yacc/bison.html -->
<html><head><title>Bison 1.24</title>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252"><!-- This HTML file has been created by texi2html 1.52
     from bison.texinfo on 2 October 1998 -->
<meta content="MSHTML 5.50.4207.2601" name=GENERATOR></head>
<body>
<h1>Bison </h1>
<h2>The YACC-compatible Parser Generator </h2>
<h2>May 1995, Bison Version 1.24 </h2>
<address>by Charles Donnelly and Richard Stallman </address>
<p>
<p>
<hr>

<p>
<h1>Table of Contents</h1>
<ul>
  <li><a name=TOC1 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC1">Introduction</a> 

  <li><a name=TOC2 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC2">Conditions 
  for Using Bison</a> 
  <li><a name=TOC3 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC3">GNU GENERAL 
  PUBLIC LICENSE</a> 
  <ul>
    <li><a name=TOC4 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC4">Preamble</a> 

    <li><a name=TOC5 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC5">TERMS AND 
    CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</a> 
    <li><a name=TOC6 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC6">How to 
    Apply These Terms to Your New Programs</a> </li></ul>
  <li><a name=TOC7 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC7">The Concepts 
  of Bison</a> 
  <ul>
    <li><a name=TOC8 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a> 
    <li><a name=TOC9 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC9">From 
    Formal Rules to Bison Input</a> 
    <li><a name=TOC10 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC10">Semantic 
    Values</a> 
    <li><a name=TOC11 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC11">Semantic 
    Actions</a> 
    <li><a name=TOC12 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC12">Bison 
    Output: the Parser File</a> 
    <li><a name=TOC13 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC13">Stages in 
    Using Bison</a> 
    <li><a name=TOC14 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC14">The 
    Overall Layout of a Bison Grammar</a> </li></ul>
  <li><a name=TOC15 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC15">Examples</a> 

  <ul>
    <li><a name=TOC16 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC16">Reverse 
    Polish Notation Calculator</a> 
    <ul>
      <li><a name=TOC17 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC17">Declarations 
      for <code>rpcalc</code></a> 
      <li><a name=TOC18 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC18">Grammar 
      Rules for <code>rpcalc</code></a> 
      <ul>
        <li><a name=TOC19 
        href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC19">Explanation 
        of <code>input</code></a> 
        <li><a name=TOC20 
        href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC20">Explanation 
        of <code>line</code></a> 
        <li><a name=TOC21 
        href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC21">Explanation 
        of <code>expr</code></a> </li></ul>
      <li><a name=TOC22 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC22">The 
      <code>rpcalc</code> Lexical Analyzer</a> 
      <li><a name=TOC23 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC23">The 
      Controlling Function</a> 
      <li><a name=TOC24 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC24">The 
      Error Reporting Routine</a> 
      <li><a name=TOC25 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC25">Running 
      Bison to Make the Parser</a> 
      <li><a name=TOC26 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC26">Compiling 
      the Parser File</a> </li></ul>
    <li><a name=TOC27 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC27">Infix 
    Notation Calculator: <code>calc</code></a> 
    <li><a name=TOC28 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC28">Simple 
    Error Recovery</a> 
    <li><a name=TOC29 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC29">Multi-Function 
    Calculator: <code>mfcalc</code></a> 
    <ul>
      <li><a name=TOC30 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC30">Declarations 
      for <code>mfcalc</code></a> 
      <li><a name=TOC31 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC31">Grammar 
      Rules for <code>mfcalc</code></a> 
      <li><a name=TOC32 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC32">The 
      <code>mfcalc</code> Symbol Table</a> </li></ul>
    <li><a name=TOC33 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC33">Exercises</a> 
    </li></ul>
  <li><a name=TOC34 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC34">Bison 
  Grammar Files</a> 
  <ul>
    <li><a name=TOC35 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC35">Outline 
    of a Bison Grammar</a> 
    <ul>
      <li><a name=TOC36 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC36">The C 
      Declarations Section</a> 
      <li><a name=TOC37 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC37">The 
      Bison Declarations Section</a> 
      <li><a name=TOC38 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC38">The 
      Grammar Rules Section</a> 
      <li><a name=TOC39 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC39">The 
      Additional C Code Section</a> </li></ul>
    <li><a name=TOC40 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
    Terminal and Nonterminal</a> 
    <li><a name=TOC41 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax of 
    Grammar Rules</a> 
    <li><a name=TOC42 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC42">Recursive 
    Rules</a> 
    <li><a name=TOC43 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC43">Defining 
    Language Semantics</a> 
    <ul>
      <li><a name=TOC44 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC44">Data 
      Types of Semantic Values</a> 
      <li><a name=TOC45 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC45">More 
      Than One Value Type</a> 
      <li><a name=TOC46 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a> 

      <li><a name=TOC47 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC47">Data 
      Types of Values in Actions</a> 
      <li><a name=TOC48 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC48">Actions 
      in Mid-Rule</a> </li></ul>
    <li><a name=TOC49 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC49">Bison 
    Declarations</a> 
    <ul>
      <li><a name=TOC50 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC50">Token 
      Type Names</a> 
      <li><a name=TOC51 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
      Precedence</a> 
      <li><a name=TOC52 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
      Collection of Value Types</a> 
      <li><a name=TOC53 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
      Symbols</a> 
      <li><a name=TOC54 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC54">Suppressing 
      Conflict Warnings</a> 
      <li><a name=TOC55 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC55">The 
      Start-Symbol</a> 
      <li><a name=TOC56 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
      (Reentrant) Parser</a> 
      <li><a name=TOC57 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC57">Bison 
      Declaration Summary</a> </li></ul>
    <li><a name=TOC58 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC58">Multiple 
    Parsers in the Same Program</a> </li></ul>
  <li><a name=TOC59 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC59">Parser 
  C-Language Interface</a> 
  <ul>
    <li><a name=TOC60 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a> 
    <li><a name=TOC61 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The 
    Lexical Analyzer Function <code>yylex</code></a> 
    <ul>
      <li><a name=TOC62 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC62">Calling 
      Convention for <code>yylex</code></a> 
      <li><a name=TOC63 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC63">Semantic 
      Values of Tokens</a> 
      <li><a name=TOC64 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC64">Textual 
      Positions of Tokens</a> 
      <li><a name=TOC65 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC65">Calling 
      Conventions for Pure Parsers</a> </li></ul>
    <li><a name=TOC66 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC66">The Error 
    Reporting Function <code>yyerror</code></a> 
    <li><a name=TOC67 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
    Features for Use in Actions</a> </li></ul>
  <li><a name=TOC68 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
  Parser Algorithm</a> 
  <ul>
    <li><a name=TOC69 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC69">Look-Ahead 
    Tokens</a> 
    <li><a name=TOC70 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC70">Shift/Reduce 
    Conflicts</a> 
    <li><a name=TOC71 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
    Precedence</a> 
    <ul>
      <li><a name=TOC72 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC72">When 
      Precedence is Needed</a> 
      <li><a name=TOC73 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC73">Specifying 
      Operator Precedence</a> 
      <li><a name=TOC74 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC74">Precedence 
      Examples</a> 
      <li><a name=TOC75 
      href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC75">How 
      Precedence Works</a> </li></ul>
    <li><a name=TOC76 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC76">Context-Dependent 
    Precedence</a> 
    <li><a name=TOC77 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC77">Parser 
    States</a> 
    <li><a name=TOC78 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC78">Reduce/Reduce 
    Conflicts</a> 
    <li><a name=TOC79 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC79">Mysterious 
    Reduce/Reduce Conflicts</a> 
    <li><a name=TOC80 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC80">Stack 
    Overflow, and How to Avoid It</a> </li></ul>
  <li><a name=TOC81 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a> 
  <li><a name=TOC82 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC82">Handling 
  Context Dependencies</a> 
  <ul>
    <li><a name=TOC83 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC83">Semantic 
    Info in Token Types</a> 
    <li><a name=TOC84 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC84">Lexical 
    Tie-ins</a> 
    <li><a name=TOC85 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC85">Lexical 
    Tie-ins and Error Recovery</a> </li></ul>
  <li><a name=TOC86 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC86">Debugging 
  Your Parser</a> 
  <li><a name=TOC87 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a> 
  <ul>
    <li><a name=TOC88 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC88">Bison 
    Options</a> 
    <li><a name=TOC89 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC89">Option 
    Cross Key</a> 
    <li><a name=TOC90 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC90">Invoking 
    Bison under VMS</a> </li></ul>
  <li><a name=TOC91 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC91">Bison 
  Symbols</a> 
  <li><a name=TOC92 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC92">Glossary</a> 

  <li><a name=TOC93 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC93">Index</a> 
  </li></ul>
<p>
<hr>

<p>
<ul>
  <h1><a name=SEC1 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC1">Introduction</a></h1>
  <p><a name=IDX1></a><em>Bison</em> is a general-purpose parser generator that 
  converts a grammar description for an LALR(1) context-free grammar into a C 
  program to parse that grammar. Once you are proficient with Bison, you may use 
  it to develop a wide range of language parsers, from those used in simple desk 
  calculators to complex programming languages. 
  <p>Bison is upward compatible with Yacc: all properly-written Yacc grammars 
  ought to work with Bison with no change. Anyone familiar with Yacc should be 
  able to use Bison with little trouble. You need to be fluent in C programming 
  in order to use Bison or to understand this manual. 
  <p>We begin with tutorial chapters that explain the basic concepts of using 
  Bison and show three explained examples, each building on the last. If you 
  don't know Bison or Yacc, start by reading these chapters. Reference chapters 
  follow which describe specific aspects of Bison in detail. 
  <p>Bison was written primarily by Robert Corbett; Richard Stallman made it 
  Yacc-compatible. This edition corresponds to version 1.24 of Bison. 
  <p>
  <h1><a name=SEC2 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC2">Conditions 
  for Using Bison</a></h1>
  <p>As of Bison version 1.24, we have changed the distribution terms for 
  <code>yyparse</code> to permit using Bison's output in non-free programs. 
  Formerly, Bison parsers could be used only in programs that were free 
  software. 
  <p>The other GNU programming tools, such as the GNU C compiler, have never had 
  such a requirement. They could always be used for non-free software. The 
  reason Bison was different was not due to a special policy decision; it 
  resulted from applying the usual General Public License to all of the Bison 
  source code. 
  <p>The output of the Bison utility--the Bison parser file--contains a verbatim 
  copy of a sizable piece of Bison, which is the code for the 
  <code>yyparse</code> function. (The actions from your grammar are inserted 
  into this function at one point, but the rest of the function is not changed.) 
  When we applied the GPL terms to the code for <code>yyparse</code>, the effect 
  was to restrict the use of Bison output to free software. 
  <p>We didn't change the terms because of sympathy for people who want to make 
  software proprietary. <strong>Software should be free.</strong> But we 
  concluded that limiting Bison's use to free software was doing little to 
  encourage people to make other software free. So we decided to make the 
  practical conditions for using Bison match the practical conditions for using 
  the other GNU tools. 
  <p>
  <h1><a name=SEC3 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC3">GNU GENERAL 
  PUBLIC LICENSE</a></h1>
  <p>Version 2, June 1991 <pre>Copyright (C) 1989, 1991 Free Software Foundation, Inc.
675 Mass Ave, Cambridge, MA 02139, USA
<p>
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</p></pre>
  <p>
  <h2><a name=SEC4 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC4">Preamble</a></h2>
  <p>The licenses for most software are designed to take away your freedom to 
  share and change it. By contrast, the GNU General Public License is intended 
  to guarantee your freedom to share and change free software--to make sure the 
  software is free for all its users. This General Public License applies to 
  most of the Free Software Foundation's software and to any other program whose 
  authors commit to using it. (Some other Free Software Foundation software is 
  covered by the GNU Library General Public License instead.) You can apply it 
  to your programs, too. 
  <p>When we speak of free software, we are referring to freedom, not price. Our 
  General Public Licenses are designed to make sure that you have the freedom to 
  distribute copies of free software (and charge for this service if you wish), 
  that you receive source code or can get it if you want it, that you can change 
  the software or use pieces of it in new free programs; and that you know you 
  can do these things. 
  <p>To protect your rights, we need to make restrictions that forbid anyone to 
  deny you these rights or to ask you to surrender the rights. These 
  restrictions translate to certain responsibilities for you if you distribute 
  copies of the software, or if you modify it. 
  <p>For example, if you distribute copies of such a program, whether gratis or 
  for a fee, you must give the recipients all the rights that you have. You must 
  make sure that they, too, receive or can get the source code. And you must 
  show them these terms so they know their rights. 
  <p>We protect your rights with two steps: (1) copyright the software, and (2) 
  offer you this license which gives you legal permission to copy, distribute 
  and/or modify the software. 
  <p>Also, for each author's protection and ours, we want to make certain that 
  everyone understands that there is no warranty for this free software. If the 
  software is modified by someone else and passed on, we want its recipients to 
  know that what they have is not the original, so that any problems introduced 
  by others will not reflect on the original authors' reputations. 
  <p>Finally, any free program is threatened constantly by software patents. We 
  wish to avoid the danger that redistributors of a free program will 
  individually obtain patent licenses, in effect making the program proprietary. 
  To prevent this, we have made it clear that any patent must be licensed for 
  everyone's free use or not licensed at all. 
  <p>The precise terms and conditions for copying, distribution and modification 
  follow. 
  <p>
  <h2><a name=SEC5 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC5">TERMS AND 
  CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</a></h2>
  <p>
  <ol>
    <li>This License applies to any program or other work which contains a 
    notice placed by the copyright holder saying it may be distributed under the 
    terms of this General Public License. The "Program", below, refers to any 
    such program or work, and a "work based on the Program" means either the 
    Program or any derivative work under copyright law: that is to say, a work 
    containing the Program or a portion of it, either verbatim or with 
    modifications and/or translated into another language. (Hereinafter, 
    translation is included without limitation in the term "modification".) Each 
    licensee is addressed as "you". 
    <p>Activities other than copying, distribution and modification are not 
    covered by this License; they are outside its scope. The act of running the 
    Program is not restricted, and the output from the Program is covered only 
    if its contents constitute a work based on the Program (independent of 
    having been made by running the Program). Whether that is true depends on 
    what the Program does. 
    <p></p>
    <li>You may copy and distribute verbatim copies of the Program's source code 
    as you receive it, in any medium, provided that you conspicuously and 
    appropriately publish on each copy an appropriate copyright notice and 
    disclaimer of warranty; keep intact all the notices that refer to this 
    License and to the absence of any warranty; and give any other recipients of 
    the Program a copy of this License along with the Program. 
    <p>You may charge a fee for the physical act of transferring a copy, and you 
    may at your option offer warranty protection in exchange for a fee. 
    <p></p>
    <li>You may modify your copy or copies of the Program or any portion of it, 
    thus forming a work based on the Program, and copy and distribute such 
    modifications or work under the terms of Section 1 above, provided that you 
    also meet all of these conditions: 
    <p>
    <ol>
      <li>You must cause the modified files to carry prominent notices stating 
      that you changed the files and the date of any change. 
      <p></p>
      <li>You must cause any work that you distribute or publish, that in whole 
      or in part contains or is derived from the Program or any part thereof, to 
      be licensed as a whole at no charge to all third parties under the terms 
      of this License. 
      <p></p>
      <li>If the modified program normally reads commands interactively when 
      run, you must cause it, when started running for such interactive use in 
      the most ordinary way, to print or display an announcement including an 
      appropriate copyright notice and a notice that there is no warranty (or 
      else, saying that you provide a warranty) and that users may redistribute 
      the program under these conditions, and telling the user how to view a 
      copy of this License. (Exception: if the Program itself is interactive but 
      does not normally print such an announcement, your work based on the 
      Program is not required to print an announcement.) 
      <p></p></li></ol>These requirements apply to the modified work as a whole. 
    If identifiable sections of that work are not derived from the Program, and 
    can be reasonably considered independent and separate works in themselves, 
    then this License, and its terms, do not apply to those sections when you 
    distribute them as separate works. But when you distribute the same sections 
    as part of a whole which is a work based on the Program, the distribution of 
    the whole must be on the terms of this License, whose permissions for other 
    licensees extend to the entire whole, and thus to each and every part 
    regardless of who wrote it. 
    <p>Thus, it is not the intent of this section to claim rights or contest 
    your rights to work written entirely by you; rather, the intent is to 
    exercise the right to control the distribution of derivative or collective 
    works based on the Program. 
    <p>In addition, mere aggregation of another work not based on the Program 
    with the Program (or with a work based on the Program) on a volume of a 
    storage or distribution medium does not bring the other work under the scope 
    of this License. 
    <p></p>
    <li>You may copy and distribute the Program (or a work based on it, under 
    Section 2) in object code or executable form under the terms of Sections 1 
    and 2 above provided that you also do one of the following: 
    <p>
    <ol>
      <li>Accompany it with the complete corresponding machine-readable source 
      code, which must be distributed under the terms of Sections 1 and 2 above 
      on a medium customarily used for software interchange; or, 
      <p></p>
      <li>Accompany it with a written offer, valid for at least three years, to 
      give any third party, for a charge no more than your cost of physically 
      performing source distribution, a complete machine-readable copy of the 
      corresponding source code, to be distributed under the terms of Sections 1 
      and 2 above on a medium customarily used for software interchange; or, 
      <p></p>
      <li>Accompany it with the information you received as to the offer to 
      distribute corresponding source code. (This alternative is allowed only 
      for noncommercial distribution and only if you received the program in 
      object code or executable form with such an offer, in accord with 
      Subsection b above.) 
      <p></p></li></ol>The source code for a work means the preferred form of the 
    work for making modifications to it. For an executable work, complete source 
    code means all the source code for all modules it contains, plus any 
    associated interface definition files, plus the scripts used to control 
    compilation and installation of the executable. However, as a special 
    exception, the source code distributed need not include anything that is 
    normally distributed (in either source or binary form) with the major 
    components (compiler, kernel, and so on) of the operating system on which 
    the executable runs, unless that component itself accompanies the 
    executable. 
    <p>If distribution of executable or object code is made by offering access 
    to copy from a designated place, then offering equivalent access to copy the 
    source code from the same place counts as distribution of the source code, 
    even though third parties are not compelled to copy the source along with 
    the object code. 
    <p></p>
    <li>You may not copy, modify, sublicense, or distribute the Program except 
    as expressly provided under this License. Any attempt otherwise to copy, 
    modify, sublicense or distribute the Program is void, and will automatically 
    terminate your rights under this License. However, parties who have received 
    copies, or rights, from you under this License will not have their licenses 
    terminated so long as such parties remain in full compliance. 
    <p></p>
    <li>You are not required to accept this License, since you have not signed 
    it. However, nothing else grants you permission to modify or distribute the 
    Program or its derivative works. These actions are prohibited by law if you 
    do not accept this License. Therefore, by modifying or distributing the 
    Program (or any work based on the Program), you indicate your acceptance of 
    this License to do so, and all its terms and conditions for copying, 
    distributing or modifying the Program or works based on it. 
    <p></p>
    <li>Each time you redistribute the Program (or any work based on the 
    Program), the recipient automatically receives a license from the original 
    licensor to copy, distribute or modify the Program subject to these terms 
    and conditions. You may not impose any further restrictions on the 
    recipients' exercise of the rights granted herein. You are not responsible 
    for enforcing compliance by third parties to this License. 
    <p></p>
    <li>If, as a consequence of a court judgment or allegation of patent 
    infringement or for any other reason (not limited to patent issues), 
    conditions are imposed on you (whether by court order, agreement or 
    otherwise) that contradict the conditions of this License, they do not 
    excuse you from the conditions of this License. If you cannot distribute so 
    as to satisfy simultaneously your obligations under this License and any 
    other pertinent obligations, then as a consequence you may not distribute 
    the Program at all. For example, if a patent license would not permit 
    royalty-free redistribution of the Program by all those who receive copies 
    directly or indirectly through you, then the only way you could satisfy both 
    it and this License would be to refrain entirely from distribution of the 
    Program. 
    <p>If any portion of this section is held invalid or unenforceable under any 
    particular circumstance, the balance of the section is intended to apply and 
    the section as a whole is intended to apply in other circumstances. 
    <p>It is not the purpose of this section to induce you to infringe any 
    patents or other property right claims or to contest validity of any such 
    claims; this section has the sole purpose of protecting the integrity of the 
    free software distribution system, which is implemented by public license 
    practices. Many people have made generous contributions to the wide range of 
    software distributed through that system in reliance on consistent 
    application of that system; it is up to the author/donor to decide if he or 
    she is willing to distribute software through any other system and a 
    licensee cannot impose that choice. 
    <p>This section is intended to make thoroughly clear what is believed to be 
    a consequence of the rest of this License. 
    <p></p>
    <li>If the distribution and/or use of the Program is restricted in certain 
    countries either by patents or by copyrighted interfaces, the original 
    copyright holder who places the Program under this License may add an 
    explicit geographical distribution limitation excluding those countries, so 
    that distribution is permitted only in or among countries not thus excluded. 
    In such case, this License incorporates the limitation as if written in the 
    body of this License. 
    <p></p>
    <li>The Free Software Foundation may publish revised and/or new versions of 
    the General Public License from time to time. Such new versions will be 
    similar in spirit to the present version, but may differ in detail to 
    address new problems or concerns. 
    <p>Each version is given a distinguishing version number. If the Program 
    specifies a version number of this License which applies to it and "any 
    later version", you have the option of following the terms and conditions 
    either of that version or of any later version published by the Free 
    Software Foundation. If the Program does not specify a version number of 
    this License, you may choose any version ever published by the Free Software 
    Foundation. 
    <p></p>
    <li>If you wish to incorporate parts of the Program into other free programs 
    whose distribution conditions are different, write to the author to ask for 
    permission. For software which is copyrighted by the Free Software 
    Foundation, write to the Free Software Foundation; we sometimes make 
    exceptions for this. Our decision will be guided by the two goals of 
    preserving the free status of all derivatives of our free software and of 
    promoting the sharing and reuse of software generally. 
    <p>
    <p><strong>NO WARRANTY</strong></p>
    <li>BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR 
    THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN 
    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES 
    PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED 
    OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO 
    THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM 
    PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR 
    CORRECTION. 
    <p></p>
    <li>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
    OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
    LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
    THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER 
    PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE 
    POSSIBILITY OF SUCH DAMAGES. 
    <p></p></li></ol>
  <p>
  <p><strong>END OF TERMS AND CONDITIONS</strong></p>
  <p>
  <h2><a name=SEC6 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC6">How to Apply 
  These Terms to Your New Programs</a></h2>
  <p>If you develop a new program, and you want it to be of the greatest 
  possible use to the public, the best way to achieve this is to make it free 
  software which everyone can redistribute and change under these terms. 
  <p>To do so, attach the following notices to the program. It is safest to 
  attach them to the start of each source file to most effectively convey the 
  exclusion of warranty; and each file should have at least the "copyright" line 
  and a pointer to where the full notice is found. 
  <p>
  <ul><pre><var>one line to give the program's name and a brief idea of what it does.</var>
Copyright (C) 19<var>yy</var>  <var>name of author</var>
<p>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
<p>
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</p></pre></ul>
  <p>Also add information on how to contact you by electronic and paper mail. If 
  the program is interactive, make it output a short notice like this when it 
  starts in an interactive mode: 
  <ul><pre>Gnomovision version 69, Copyright (C) 19<var>yy</var> <var>name of author</var>
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details 
type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
</pre></ul>
  <p>The hypothetical commands <samp>`show w'</samp> and <samp>`show c'</samp> 
  should show the appropriate parts of the General Public License. Of course, 
  the commands you use may be called something other than <samp>`show w'</samp> 
  and <samp>`show c'</samp>; they could even be mouse-clicks or menu 
  items--whatever suits your program. 
  <p>You should also get your employer (if you work as a programmer) or your 
  school, if any, to sign a "copyright disclaimer" for the program, if 
  necessary. Here is a sample; alter the names: 
  <p>
  <ul><pre>Yoyodyne, Inc., hereby disclaims all copyright interest in the program
`Gnomovision' (which makes passes at compilers) written by James Hacker.
<p>
<var>signature of Ty Coon</var>, 1 April 1989
Ty Coon, President of Vice
</p></pre></ul>
  <p>This General Public License does not permit incorporating your program into 
  proprietary programs. If your program is a subroutine library, you may 
  consider it more useful to permit linking proprietary applications with the 
  library. If this is what you want to do, use the GNU Library General Public 
  License instead of this License. 
  <p>
  <h1><a name=SEC7 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC7">The Concepts 
  of Bison</a></h1>
  <p>This chapter introduces many of the basic concepts without which the 
  details of Bison will not make sense. If you do not already know how to use 
  Bison or Yacc, we suggest you start by reading this chapter carefully. 
  <h2><a name=SEC8 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC8">Languages 
  and Context-Free Grammars</a></h2>
  <p><a name=IDX2></a><a name=IDX3></a><bol>In order for Bison to parse a 
  language, it must be described by a <em>context-free grammar</em>. This means 
  that you specify one or more <em>syntactic groupings</em> and give rules for 
  constructing them from their parts. For example, in the C language, one kind 
  of grouping is called an `expression'. One rule for making an expression might 
  be, "An expression can be made of a minus sign and another expression". 
  Another would be, "An expression can be an integer". As you can see, rules are 
  often recursive, but there must be at least one rule which leads out of the 
  recursion. 
  <p><a name=IDX4></a><a name=IDX5></a>The most common formal system for 
  presenting such rules for humans to read is <em>Backus-Naur Form</em> or 
  "BNF", which was developed in order to specify the language Algol 60. Any 
  grammar expressed in BNF is a context-free grammar. The input to Bison is 
  essentially machine-readable BNF. 
  <p>Not all context-free languages can be handled by Bison, only those that are 
  LALR(1). In brief, this means that it must be possible to tell how to parse 
  any portion of an input string with just a single token of look-ahead. 
  Strictly speaking, that is a description of an LR(1) grammar, and LALR(1) 
  involves additional restrictions that are hard to explain simply; but it is 
  rare in actual practice to find an LR(1) grammar that fails to be LALR(1). See 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC79">Mysterious 
  Reduce/Reduce Conflicts</a>, for more information on this. 
  <p><a name=IDX6></a><a name=IDX7></a><a name=IDX8></a><a name=IDX9></a>In the 
  formal grammatical rules for a language, each kind of syntactic unit or 
  grouping is named by a <em>symbol</em>. Those which are built by grouping 
  smaller constructs according to grammatical rules are called <em>nonterminal 
  symbols</em>; those which can't be subdivided are called <em>terminal 
  symbols</em> or <em>token types</em>. We call a piece of input corresponding 
  to a single terminal symbol a <em>token</em>, and a piece corresponding to a 
  single nonterminal symbol a <em>grouping</em>. We can use the C language as an 
  example of what symbols, terminal and nonterminal, mean. The tokens of C are 
  identifiers, constants (numeric and string), and the various keywords, 
  arithmetic operators and punctuation marks. So the terminal symbols of a 
  grammar for C include `identifier', `number', `string', plus one symbol for 
  each keyword, operator or punctuation mark: `if', `return', `const', `static', 
  `int', `char', `plus-sign', `open-brace', `close-brace', `comma' and many 
  more. (These tokens can be subdivided into characters, but that is a matter of 
  lexicography, not grammar.) 
  <p>Here is a simple C function subdivided into tokens: 
  <p>
  <blockquote><pre>int             /* keyword `int' */
square (x)      /* identifier, open-paren, */
                /* identifier, close-paren */
     int x;     /* keyword `int', identifier, semicolon */
{               /* open-brace */
  return x * x; /* keyword `return', identifier, */
                /* asterisk, identifier, semicolon */
}               /* close-brace */
</pre></blockquote>
  <p>The syntactic groupings of C include the expression, the statement, the 
  declaration, and the function definition. These are represented in the grammar 
  of C by nonterminal symbols `expression', `statement', `declaration' and 
  `function definition'. The full grammar uses dozens of additional language 
  constructs, each with its own nonterminal symbol, in order to express the 
  meanings of these four. The example above is a function definition; it 
  contains one declaration, and one statement. In the statement, each 
  <samp>`x'</samp> is an expression and so is <samp>`x * x'</samp>. Each 
  nonterminal symbol must have grammatical rules showing how it is made out of 
  simpler constructs. For example, one kind of C statement is the 
  <code>return</code> statement; this would be described with a grammar rule 
  which reads informally as follows: 
  <blockquote>
    <p>A `statement' can be made of a `return' keyword, an `expression' and a 
    `semicolon'. </p></blockquote>
  <p>There would be many other rules for `statement', one for each kind of 
  statement in C. 
  <p><a name=IDX10></a>One nonterminal symbol must be distinguished as the 
  special one which defines a complete utterance in the language. It is called 
  the <em>start symbol</em>. In a compiler, this means a complete input program. 
  In the C language, the nonterminal symbol `sequence of definitions and 
  declarations' plays this role. 
  <p>For example, <samp>`1 + 2'</samp> is a valid C expression--a valid part of 
  a C program--but it is not valid as an <em>entire</em> C program. In the 
  context-free grammar of C, this follows from the fact that `expression' is not 
  the start symbol. 
  <p>The Bison parser reads a sequence of tokens as its input, and groups the 
  tokens using the grammar rules. If the input is valid, the end result is that 
  the entire token sequence reduces to a single grouping whose symbol is the 
  grammar's start symbol. If we use a grammar for C, the entire input must be a 
  `sequence of definitions and declarations'. If not, the parser reports a 
  syntax error. 
  <p>
  <h2><a name=SEC9 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC9">From Formal 
  Rules to Bison Input</a></h2>
  <p><a name=IDX11></a><a name=IDX12></a><a name=IDX13></a>A formal grammar is a 
  mathematical construct. To define the language for Bison, you must write a 
  file expressing the grammar in Bison syntax: a <em>Bison grammar</em> file. 
  See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC34">Bison 
  Grammar Files</a>. A nonterminal symbol in the formal grammar is represented 
  in Bison input as an identifier, like an identifier in C. By convention, it 
  should be in lower case, such as <code>expr</code>, <code>stmt</code> or 
  <code>declaration</code>. The Bison representation for a terminal symbol is 
  also called a <em>token type</em>. Token types as well can be represented as 
  C-like identifiers. By convention, these identifiers should be upper case to 
  distinguish them from nonterminals: for example, <code>INTEGER</code>, 
  <code>IDENTIFIER</code>, <code>IF</code> or <code>RETURN</code>. A terminal 
  symbol that stands for a particular keyword in the language should be named 
  after that keyword converted to upper case. The terminal symbol 
  <code>error</code> is reserved for error recovery. 
  <p>See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
  Terminal and Nonterminal</a>. A terminal symbol can also be represented as a 
  character literal, just like a C character constant. You should do this 
  whenever a token is just a single character (parenthesis, plus-sign, etc.): 
  use that same character in a literal as the terminal symbol for that token. 
  <p>The grammar rules also have an expression in Bison syntax. For example, 
  here is the Bison rule for a C <code>return</code> statement. The semicolon in 
  quotes is a literal character token, representing part of the C syntax for the 
  statement; the naked semicolon, and the colon, are Bison punctuation used in 
  every rule. 
  <p>
  <blockquote><pre>stmt:   RETURN expr ';'
        ;
</pre></blockquote>
  <p>See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax of 
  Grammar Rules</a>. 
  <p>
  <h2><a name=SEC10 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC10">Semantic 
  Values</a></h2>
  <p><a name=IDX14></a><a name=IDX15></a>A formal grammar selects tokens only by 
  their classifications: for example, if a rule mentions the terminal symbol 
  `integer constant', it means that <em>any</em> integer constant is 
  grammatically valid in that position. The precise value of the constant is 
  irrelevant to how to parse the input: if <samp>`x+4'</samp> is grammatical 
  then <samp>`x+1'</samp> or <samp>`x+3989'</samp> is equally grammatical. 
  <p>But the precise value is very important for what the input means once it is 
  parsed. A compiler is useless if it fails to distinguish between 4, 1 and 3989 
  as constants in the program! Therefore, each token in a Bison grammar has both 
  a token type and a <em>semantic value</em>. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC43">Defining 
  Language Semantics</a>, for details. 
  <p>The token type is a terminal symbol defined in the grammar, such as 
  <code>INTEGER</code>, <code>IDENTIFIER</code> or <code>','</code>. It tells 
  everything you need to know to decide where the token may validly appear and 
  how to group it with other tokens. The grammar rules know nothing about tokens 
  except their types. 
  <p>The semantic value has all the rest of the information about the meaning of 
  the token, such as the value of an integer, or the name of an identifier. (A 
  token such as <code>','</code> which is just punctuation doesn't need to have 
  any semantic value.) 
  <p>For example, an input token might be classified as token type 
  <code>INTEGER</code> and have the semantic value 4. Another input token might 
  have the same token type <code>INTEGER</code> but value 3989. When a grammar 
  rule says that <code>INTEGER</code> is allowed, either of these tokens is 
  acceptable because each is an <code>INTEGER</code>. When the parser accepts 
  the token, it keeps track of the token's semantic value. 
  <p>Each grouping can also have a semantic value as well as its nonterminal 
  symbol. For example, in a calculator, an expression typically has a semantic 
  value that is a number. In a compiler for a programming language, an 
  expression typically has a semantic value that is a tree structure describing 
  the meaning of the expression. 
  <p>
  <h2><a name=SEC11 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC11">Semantic 
  Actions</a></h2>
  <p><a name=IDX16></a><a name=IDX17></a>In order to be useful, a program must 
  do more than parse input; it must also produce some output based on the input. 
  In a Bison grammar, a grammar rule can have an <em>action</em> made up of C 
  statements. Each time the parser recognizes a match for that rule, the action 
  is executed. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 

  <p>Most of the time, the purpose of an action is to compute the semantic value 
  of the whole construct from the semantic values of its parts. For example, 
  suppose we have a rule which says an expression can be the sum of two 
  expressions. When the parser recognizes such a sum, each of the subexpressions 
  has a semantic value which describes how it was built up. The action for this 
  rule should create a similar sort of value for the newly recognized larger 
  expression. For example, here is a rule that says an expression can be the sum 
  of two subexpressions: 
  <p>
  <blockquote><pre>expr: expr '+' expr   { $$ = $1 + $3; }
        ;
</pre></blockquote>
  <p>The action says how to produce the semantic value of the sum expression 
  from the values of the two subexpressions. 
  <h2><a name=SEC12 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC12">Bison 
  Output: the Parser File</a></h2>
  <p><a name=IDX18></a><a name=IDX19></a><a name=IDX20></a><a 
  name=IDX21></a>When you run Bison, you give it a Bison grammar file as input. 
  The output is a C source file that parses the language described by the 
  grammar. This file is called a <em>Bison parser</em>. Keep in mind that the 
  Bison utility and the Bison parser are two distinct programs: the Bison 
  utility is a program whose output is the Bison parser that becomes part of 
  your program. 
  <p>The job of the Bison parser is to group tokens into groupings according to 
  the grammar rules--for example, to build identifiers and operators into 
  expressions. As it does this, it runs the actions for the grammar rules it 
  uses. 
  <p>The tokens come from a function called the <em>lexical analyzer</em> that 
  you must supply in some fashion (such as by writing it in C). The Bison parser 
  calls the lexical analyzer each time it wants a new token. It doesn't know 
  what is "inside" the tokens (though their semantic values may reflect this). 
  Typically the lexical analyzer makes the tokens by parsing characters of text, 
  but Bison does not depend on this. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The Lexical 
  Analyzer Function <code>yylex</code></a>. The Bison parser file is C code 
  which defines a function named <code>yyparse</code> which implements that 
  grammar. This function does not make a complete C program: you must supply 
  some additional functions. One is the lexical analyzer. Another is an 
  error-reporting function which the parser calls to report an error. In 
  addition, a complete C program must start with a function called 
  <code>main</code>; you have to provide this, and arrange for it to call 
  <code>yyparse</code> or the parser will never run. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC59">Parser 
  C-Language Interface</a>. Aside from the token type names and the symbols in 
  the actions you write, all variable and function names used in the Bison 
  parser file begin with <samp>`yy'</samp> or <samp>`YY'</samp>. This includes 
  interface functions such as the lexical analyzer function <code>yylex</code>, 
  the error reporting function <code>yyerror</code> and the parser function 
  <code>yyparse</code> itself. This also includes numerous identifiers used for 
  internal purposes. Therefore, you should avoid using C identifiers starting 
  with <samp>`yy'</samp> or <samp>`YY'</samp> in the Bison grammar file except 
  for the ones defined in this manual. 
  <h2><a name=SEC13 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC13">Stages in 
  Using Bison</a></h2>
  <p><a name=IDX22></a><a name=IDX23></a>The actual language-design process 
  using Bison, from grammar specification to a working compiler or interpreter, 
  has these parts: 
  <ol>
    <li>Formally specify the grammar in a form recognized by Bison (see section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC34">Bison 
    Grammar Files</a>). For each grammatical rule in the language, describe the 
    action that is to be taken when an instance of that rule is recognized. The 
    action is described by a sequence of C statements. 
    <li>Write a lexical analyzer to process input and pass tokens to the parser. 
    The lexical analyzer may be written by hand in C (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The 
    Lexical Analyzer Function <code>yylex</code></a>). It could also be produced 
    using Lex, but the use of Lex is not discussed in this manual. 
    <li>Write a controlling function that calls the Bison-produced parser. 
    <li>Write error-reporting routines. </li></ol>
  <p>To turn this source code as written into a runnable program, you must 
  follow these steps: 
  <ol>
    <li>Run Bison on the grammar to produce the parser. 
    <li>Compile the code output by Bison, as well as any other source files. 
    <li>Link the object files to produce the finished product. </li></ol>
  <p>
  <h2><a name=SEC14 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC14">The Overall 
  Layout of a Bison Grammar</a></h2>
  <p><a name=IDX24></a><a name=IDX25></a><a name=IDX26></a><a name=IDX27></a>The 
  input file for the Bison utility is a <em>Bison grammar file</em>. The general 
  form of a Bison grammar file is as follows: <pre>%{
<var>C declarations</var>
%}
<var>Bison declarations</var>
%%
<var>Grammar rules</var>
%%
<var>Additional C code</var>
</pre>
  <p>The <samp>`%%'</samp>, <samp>`%{'</samp> and <samp>`%}'</samp> are 
  punctuation that appears in every Bison grammar file to separate the sections. 
  The C declarations may define types and variables used in the actions. You can 
  also use preprocessor commands to define macros used there, and use 
  <code>#include</code> to include header files that do any of these things. The 
  Bison declarations declare the names of the terminal and nonterminal symbols, 
  and may also describe operator precedence and the data types of semantic 
  values of various symbols. 
  <p>The grammar rules define how to construct each nonterminal symbol from its 
  parts. 
  <p>The additional C code can contain any C code you want to use. Often the 
  definition of the lexical analyzer <code>yylex</code> goes here, plus 
  subroutines called by the actions in the grammar rules. In a simple program, 
  all the rest of the program can go here. 
  <p>
  <h1><a name=SEC15 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC15">Examples</a></h1>
  <p><a name=IDX28></a><a name=IDX29></a>Now we show and explain three sample 
  programs written using Bison: a reverse polish notation calculator, an 
  algebraic (infix) notation calculator, and a multi-function calculator. All 
  three have been tested under BSD Unix 4.3; each produces a usable, though 
  limited, interactive desk-top calculator. 
  <p>These examples are simple, but Bison grammars for real programming 
  languages are written the same way. 
  <p>
  <h2><a name=SEC16 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC16">Reverse 
  Polish Notation Calculator</a></h2>
  <p><a name=IDX30></a><a name=IDX31></a><a name=IDX32></a><a name=IDX33></a>The 
  first example is that of a simple double-precision <em>reverse polish 
  notation</em> calculator (a calculator using postfix operators). This example 
  provides a good starting point, since operator precedence is not an issue. 
  <p>The second example will illustrate how operator precedence is handled. The 
  source code for this calculator is named <tt>`rpcalc.y'</tt>. The 
  <samp>`.y'</samp> extension is a convention used for Bison input files. 
  <h3><a name=SEC17 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC17">Declarations 
  for <code>rpcalc</code></a></h3>
  <p>Here are the C and Bison declarations for the reverse polish notation 
  calculator. As in C, comments are placed between <samp>`/*...*/'</samp>. 
  <p><pre>/* Reverse polish notation calculator. */
%{
#define YYSTYPE double
#include &lt;math.h&gt;
%}
%token NUM
%% /* Grammar rules and actions follow */
</pre>
  <p>The C declarations section (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC36">The C 
  Declarations Section</a>) contains two preprocessor directives. 
  <p>The <code>#define</code> directive defines the macro <code>YYSTYPE</code>, 
  thus specifying the C data type for semantic values of both tokens and 
  groupings (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC44">Data Types 
  of Semantic Values</a>). The Bison parser will use whatever type 
  <code>YYSTYPE</code> is defined as; if you don't define it, <code>int</code> 
  is the default. Because we specify <code>double</code>, each token and each 
  expression has an associated value, which is a floating point number. 
  <p>The <code>#include</code> directive is used to declare the exponentiation 
  function <code>pow</code>. 
  <p>The second section, Bison declarations, provides information to Bison about 
  the token types (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC37">The Bison 
  Declarations Section</a>). Each terminal symbol that is not a single-character 
  literal must be declared here. (Single-character literals normally don't need 
  to be declared.) In this example, all the arithmetic operators are designated 
  by single-character literals, so the only terminal symbol that needs to be 
  declared is <code>NUM</code>, the token type for numeric constants. 
  <p>
  <h3><a name=SEC18 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC18">Grammar 
  Rules for <code>rpcalc</code></a></h3>
  <p>Here are the grammar rules for the reverse polish notation calculator. 
  <p>
  <blockquote><pre>input:    /* empty */
        | input line
;
line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;
exp:      NUM             { $$ = $1;         }
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        | exp exp '*'     { $$ = $1 * $2;    }
        | exp exp '/'     { $$ = $1 / $2;    }
      /* Exponentiation */
        | exp exp '^'     { $$ = pow ($1, $2); }
      /* Unary minus    */
        | exp 'n'         { $$ = -$1;        }
;
%%
</pre></blockquote>
  <p>The groupings of the rpcalc "language" defined here are the expression 
  (given the name <code>exp</code>), the line of input (<code>line</code>), and 
  the complete input transcript (<code>input</code>). Each of these nonterminal 
  symbols has several alternate rules, joined by the <samp>`|'</samp> punctuator 
  which is read as "or". The following sections explain what these rules mean. 
  <p>The semantics of the language is determined by the actions taken when a 
  grouping is recognized. The actions are the C code that appears inside braces. 
  See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 

  <p>You must specify these actions in C, but Bison provides the means for 
  passing semantic values between the rules. In each action, the pseudo-variable 
  <code>$$</code> stands for the semantic value for the grouping that the rule 
  is going to construct. Assigning a value to <code>$$</code> is the main job of 
  most actions. The semantic values of the components of the rule are referred 
  to as <code>$1</code>, <code>$2</code>, and so on. 
  <p>
  <h4><a name=SEC19 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC19">Explanation 
  of <code>input</code></a></h4>
  <p>Consider the definition of <code>input</code>: 
  <p>
  <blockquote><pre>input:    /* empty */
        | input line
;
</pre></blockquote>
  <p>This definition reads as follows: "A complete input is either an empty 
  string, or a complete input followed by an input line". Notice that "complete 
  input" is defined in terms of itself. This definition is said to be <em>left 
  recursive</em> since <code>input</code> appears always as the leftmost symbol 
  in the sequence. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC42">Recursive 
  Rules</a>. 
  <p>The first alternative is empty because there are no symbols between the 
  colon and the first <samp>`|'</samp>; this means that <code>input</code> can 
  match an empty string of input (no tokens). We write the rules this way 
  because it is legitimate to type <kbd>Ctrl-d</kbd> right after you start the 
  calculator. 
  <p>It's conventional to put an empty alternative first and write the comment 
  <samp>`/* empty */'</samp> in it. 
  <p>The second alternate rule (<code>input line</code>) handles all nontrivial 
  input. It means, "After reading any number of lines, read one more line if 
  possible." The left recursion makes this rule into a loop. Since the first 
  alternative matches empty input, the loop can be executed zero or more times. 
  <p>The parser function <code>yyparse</code> continues to process input until a 
  grammatical error is seen or the lexical analyzer says there are no more input 
  tokens; we will arrange for the latter to happen at end of file. 
  <h4><a name=SEC20 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC20">Explanation 
  of <code>line</code></a></h4>
  <p>Now consider the definition of <code>line</code>: <pre><blockquote>
line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;
</blockquote></pre>
  <blockquote></blockquote>
  <p>The first alternative is a token which is a newline character; this means 
  that rpcalc accepts a blank line (and ignores it, since there is no action). 
  The second alternative is an expression followed by a newline. This is the 
  alternative that makes rpcalc useful. The semantic value of the 
  <code>exp</code> grouping is the value of <code>$1</code> because the 
  <code>exp</code> in question is the first symbol in the alternative. The 
  action prints this value, which is the result of the computation the user 
  asked for. This action is unusual because it does not assign a value to 
  <code>$$</code>. As a consequence, the semantic value associated with the 
  <code>line</code> is uninitialized (its value will be unpredictable). This 
  would be a bug if that value were ever used, but we don't use it: once rpcalc 
  has printed the value of the user's input line, that value is no longer 
  needed. 
  <h4><a name=SEC21 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC21">Explanation 
  of <code>expr</code></a></h4>
  <p>The <code>exp</code> grouping has several rules, one for each kind of 
  expression. The first rule handles the simplest expressions: those that are 
  just numbers. The second handles an addition-expression, which looks like two 
  expressions followed by a plus-sign. The third handles subtraction, and so on. 

  <blockquote><pre>exp:      NUM
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        ...
        ;
</pre></blockquote>
  <p>We have used <samp>`|'</samp> to join all the rules for <code>exp</code>, 
  but we could equally well have written them separately: 
  <blockquote><pre>exp:      NUM ;
exp:      exp exp '+'     { $$ = $1 + $2;    } ;
exp:      exp exp '-'     { $$ = $1 - $2;    } ;
        ...
</pre></blockquote>
  <p>Most of the rules have actions that compute the value of the expression in 
  terms of the value of its parts. For example, in the rule for addition, 
  <code>$1</code> refers to the first component <code>exp</code> and 
  <code>$2</code> refers to the second one. The third component, 
  <code>'+'</code>, has no meaningful associated semantic value, but if it had 
  one you could refer to it as <code>$3</code>. When <code>yyparse</code> 
  recognizes a sum expression using this rule, the sum of the two 
  subexpressions' values is produced as the value of the entire expression. See 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 
  You don't have to give an action for every rule. When a rule has no action, 
  Bison by default copies the value of <code>$1</code> into <code>$$</code>. 
  This is what happens in the first rule (the one that uses <code>NUM</code>). 
  The formatting shown here is the recommended convention, but Bison does not 
  require it. You can add or change whitespace as much as you wish. For example, 
  this: <pre>exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...
</pre>
  <p>means the same thing as this: <pre>exp:      NUM
        | exp exp '+'    { $$ = $1 + $2; }
        | ...
</pre>
  <p>The latter, however, is much more readable. 
  <h3><a name=SEC22 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC22">The 
  <code>rpcalc</code> Lexical Analyzer</a></h3>
  <p><a name=IDX34></a><a name=IDX35></a>The lexical analyzer's job is low-level 
  parsing: converting characters or sequences of characters into tokens. The 
  Bison parser gets its tokens by calling the lexical analyzer. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The Lexical 
  Analyzer Function <code>yylex</code></a>. Only a simple lexical analyzer is 
  needed for the RPN calculator. This lexical analyzer skips blanks and tabs, 
  then reads in numbers as <code>double</code> and returns them as 
  <code>NUM</code> tokens. Any other character that isn't part of a number is a 
  separate token. Note that the token-code for such a single-character token is 
  the character itself. The return value of the lexical analyzer function is a 
  numeric code which represents a token type. The same text used in Bison rules 
  to stand for this token type is also a C expression for the numeric code for 
  the type. This works in two ways. If the token type is a character literal, 
  then its numeric code is the ASCII code for that character; you can use the 
  same character literal in the lexical analyzer to express the number. If the 
  token type is an identifier, that identifier is defined by Bison as a C macro 
  whose definition is the appropriate number. In this example, therefore, 
  <code>NUM</code> becomes a macro for <code>yylex</code> to use. The semantic 
  value of the token (if it has one) is stored into the global variable 
  <code>yylval</code>, which is where the Bison parser will look for it. (The C 
  data type of <code>yylval</code> is <code>YYSTYPE</code>, which was defined at 
  the beginning of the grammar; see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC17">Declarations 
  for <code>rpcalc</code></a>.) A token type code of zero is returned if the 
  end-of-file is encountered. (Bison recognizes any nonpositive value as 
  indicating the end of the input.) Here is the code for the lexical analyzer: <pre>/* Lexical analyzer returns a double floating point 
   number on the stack and the token NUM, or the ASCII
   character read if not a number.  Skips all blanks
   and tabs, returns 0 for EOF. */
#include &lt;ctype.h&gt;
yylex ()
{
  int c;
  /* skip white space  */
  while ((c = getchar ()) == ' ' || c == '\t')  
    ;
  /* process numbers   */
  if (c == '.' || isdigit (c))                
    {
      ungetc (c, stdin);
      scanf ("%lf", &amp;yylval);
      return NUM;
    }
  /* return end-of-file  */
  if (c == EOF)                            
    return 0;
  /* return single chars */
  return c;                                
}
</pre>
  <p>
  <h3><a name=SEC23 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC23">The 
  Controlling Function</a></h3>
  <p><a name=IDX36></a><a name=IDX37></a>In keeping with the spirit of this 
  example, the controlling function is kept to the bare minimum. The only 
  requirement is that it call <code>yyparse</code> to start the process of 
  parsing. <pre>main ()
{
  yyparse ();
}
</pre>
  <p>
  <h3><a name=SEC24 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC24">The Error 
  Reporting Routine</a></h3>
  <p><a name=IDX38></a>When <code>yyparse</code> detects a syntax error, it 
  calls the error reporting function <code>yyerror</code> to print an error 
  message (usually but not always <code>"parse error"</code>). It is up to the 
  programmer to supply <code>yyerror</code> (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC59">Parser 
  C-Language Interface</a>), so here is the definition we will use: <pre>#include &lt;stdio.h&gt;
yyerror (s)  /* Called by yyparse on error */
     char *s;
{
  printf ("%s\n", s);
}
</pre>
  <p>After <code>yyerror</code> returns, the Bison parser may recover from the 
  error and continue parsing if the grammar contains a suitable error rule (see 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>). Otherwise, <code>yyparse</code> returns nonzero. We have not 
  written any error rules in this example, so any invalid input will cause the 
  calculator program to exit. This is not clean behavior for a real calculator, 
  but it is adequate in the first example. 
  <h3><a name=SEC25 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC25">Running 
  Bison to Make the Parser</a></h3>
  <p><a name=IDX39></a>Before running Bison to produce a parser, we need to 
  decide how to arrange all the source code in one or more source files. For 
  such a simple example, the easiest thing is to put everything in one file. The 
  definitions of <code>yylex</code>, <code>yyerror</code> and <code>main</code> 
  go at the end, in the "additional C code" section of the file (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC14">The Overall 
  Layout of a Bison Grammar</a>). For a large project, you would probably have 
  several source files, and use <code>make</code> to arrange to recompile them. 
  With all the source in a single file, you use the following command to convert 
  it into a parser file: <pre>bison <var>file_name</var>.y
</pre>
  <p>In this example the file was called <tt>`rpcalc.y'</tt> (for "Reverse 
  Polish CALCulator"). Bison produces a file named 
  <tt>`<var>file_name</var>.tab.c'</tt>, removing the <samp>`.y'</samp> from the 
  original file name. The file output by Bison contains the source code for 
  <code>yyparse</code>. The additional functions in the input file 
  (<code>yylex</code>, <code>yyerror</code> and <code>main</code>) are copied 
  verbatim to the output. 
  <h3><a name=SEC26 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC26">Compiling 
  the Parser File</a></h3>
  <p><a name=IDX40></a>Here is how to compile and run the parser file: <pre># List files in current directory.
% ls
rpcalc.tab.c  rpcalc.y
# Compile the Bison parser.
# <samp>`-lm'</samp> tells compiler to search math library for <code>pow</code>.
% cc rpcalc.tab.c -lm -o rpcalc
# List files again.
% ls
rpcalc  rpcalc.tab.c  rpcalc.y
</pre>
  <p>The file <tt>`rpcalc'</tt> now contains the executable code. Here is an 
  example session using <code>rpcalc</code>. <pre>% rpcalc
4 9 +
13
3 7 + 3 4 5 *+-
-13
3 7 + 3 4 5 * + - n              Note the unary minus, <samp>`n'</samp>
13
5 6 / 4 n +
-3.166666667
3 4 ^                            Exponentiation
81
^D                               End-of-file indicator
%
</pre>
  <p>
  <h2><a name=SEC27 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC27">Infix 
  Notation Calculator: <code>calc</code></a></h2>
  <p><a name=IDX41></a><a name=IDX42></a><a name=IDX43></a>We now modify rpcalc 
  to handle infix operators instead of postfix. Infix notation involves the 
  concept of operator precedence and the need for parentheses nested to 
  arbitrary depth. Here is the Bison code for <tt>`calc.y'</tt>, an infix 
  desk-top calculator. <pre>/* Infix notation calculator--calc */
%{
#define YYSTYPE double
#include &lt;math.h&gt;
%}
/* BISON Declarations */
%token NUM
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */
/* Grammar follows */
%%
input:    /* empty string */
        | input line
;
line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;
exp:      NUM                { $$ = $1;         }
        | exp '+' exp        { $$ = $1 + $3;    }
        | exp '-' exp        { $$ = $1 - $3;    }
        | exp '*' exp        { $$ = $1 * $3;    }
        | exp '/' exp        { $$ = $1 / $3;    }
        | '-' exp  %prec NEG { $$ = -$2;        }
        | exp '^' exp        { $$ = pow ($1, $3); }
        | '(' exp ')'        { $$ = $2;         }
;
%%
</pre>
  <p>The functions <code>yylex</code>, <code>yyerror</code> and 
  <code>main</code> can be the same as before. There are two important new 
  features shown in this code. In the second section (Bison declarations), 
  <code>%left</code> declares token types and says they are left-associative 
  operators. The declarations <code>%left</code> and <code>%right</code> (right 
  associativity) take the place of <code>%token</code> which is used to declare 
  a token type name without associativity. (These tokens are single-character 
  literals, which ordinarily don't need to be declared. We declare them here to 
  specify the associativity.) Operator precedence is determined by the line 
  ordering of the declarations; the higher the line number of the declaration 
  (lower on the page or screen), the higher the precedence. Hence, 
  exponentiation has the highest precedence, unary minus (<code>NEG</code>) is 
  next, followed by <samp>`*'</samp> and <samp>`/'</samp>, and so on. See 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
  Precedence</a>. The other important new feature is the <code>%prec</code> in 
  the grammar section for the unary minus operator. The <code>%prec</code> 
  simply instructs Bison that the rule <samp>`| '-' exp'</samp> has the same 
  precedence as <code>NEG</code>---in this case the next-to-highest. See section 
  <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC76">Context-Dependent 
  Precedence</a>. Here is a sample run of <tt>`calc.y'</tt>: <pre>% calc
4 + 4.5 - (34/(8*3+-3))
6.880952381
-56 + 2
-54
3 ^ 2
9
</pre>
  <p>
  <h2><a name=SEC28 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC28">Simple 
  Error Recovery</a></h2>
  <p><a name=IDX44></a>Up to this point, this manual has not addressed the issue 
  of <em>error recovery</em>---how to continue parsing after the parser detects 
  a syntax error. All we have handled is error reporting with 
  <code>yyerror</code>. Recall that by default <code>yyparse</code> returns 
  after calling <code>yyerror</code>. This means that an erroneous input line 
  causes the calculator program to exit. Now we show how to rectify this 
  deficiency. The Bison language itself includes the reserved word 
  <code>error</code>, which may be included in the grammar rules. In the example 
  below it has been added to one of the alternatives for <code>line</code>: <pre>line:     '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;
</pre>
  <p>This addition to the grammar allows for simple error recovery in the event 
  of a parse error. If an expression that cannot be evaluated is read, the error 
  will be recognized by the third rule for <code>line</code>, and parsing will 
  continue. (The <code>yyerror</code> function is still called upon to print its 
  message as well.) The action executes the statement <code>yyerrok</code>, a 
  macro defined automatically by Bison; its meaning is that error recovery is 
  complete (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>). Note the difference between <code>yyerrok</code> and 
  <code>yyerror</code>; neither one is a misprint. This form of error recovery 
  deals with syntax errors. There are other kinds of errors; for example, 
  division by zero, which raises an exception signal that is normally fatal. A 
  real calculator program must handle this signal and use <code>longjmp</code> 
  to return to <code>main</code> and resume parsing input lines; it would also 
  have to discard the rest of the current line of input. We won't discuss this 
  issue further because it is not specific to Bison programs. 
  <h2><a name=SEC29 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC29">Multi-Function 
  Calculator: <code>mfcalc</code></a></h2>
  <p><a name=IDX45></a><a name=IDX46></a><a name=IDX47></a>Now that the basics 
  of Bison have been discussed, it is time to move on to a more advanced 
  problem. The above calculators provided only five functions, <samp>`+'</samp>, 
  <samp>`-'</samp>, <samp>`*'</samp>, <samp>`/'</samp> and <samp>`^'</samp>. It 
  would be nice to have a calculator that provides other mathematical functions 
  such as <code>sin</code>, <code>cos</code>, etc. It is easy to add new 
  operators to the infix calculator as long as they are only single-character 
  literals. The lexical analyzer <code>yylex</code> passes back all non-number 
  characters as tokens, so new grammar rules suffice for adding a new operator. 
  But we want something more flexible: built-in functions whose syntax has this 
  form: <pre><var>function_name</var> (<var>argument</var>)
</pre>
  <p>At the same time, we will add memory to the calculator, by allowing you to 
  create named variables, store values in them, and use them later. Here is a 
  sample session with the multi-function calculator: <pre>% mfcalc
pi = 3.141592653589
3.1415926536
sin(pi)
0.0000000000
alpha = beta1 = 2.3
2.3000000000
alpha
2.3000000000
ln(alpha)
0.8329091229
exp(ln(beta1))
2.3000000000
%
</pre>
  <p>Note that multiple assignment and nested function calls are permitted. 
  <h3><a name=SEC30 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC30">Declarations 
  for <code>mfcalc</code></a></h3>
  <p>Here are the C and Bison declarations for the multi-function calculator. <pre>%{
#include &lt;math.h&gt;  /* For math functions, cos(), sin(), etc. */
#include "calc.h"  /* Contains definition of `symrec'        */
%}
%union {
double     val;  /* For returning numbers.                   */
symrec  *tptr;   /* For returning symbol-table pointers      */
}
%token &lt;val&gt;  NUM        /* Simple double precision number   */
%token &lt;tptr&gt; VAR FNCT   /* Variable and Function            */
%type  &lt;val&gt;  exp
%right '='
%left '-' '+'
%left '*' '/'
%left NEG     /* Negation--unary minus */
%right '^'    /* Exponentiation        */
/* Grammar follows */
%%
</pre>
  <p>The above grammar introduces only two new features of the Bison language. 
  These features allow semantic values to have various data types (see section 
  <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC45">More 
  Than One Value Type</a>). The <code>%union</code> declaration specifies the 
  entire list of possible types; this is instead of defining 
  <code>YYSTYPE</code>. The allowable types are now double-floats (for 
  <code>exp</code> and <code>NUM</code>) and pointers to entries in the symbol 
  table. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
  Collection of Value Types</a>. Since values can now have various types, it is 
  necessary to associate a type with each grammar symbol whose semantic value is 
  used. These symbols are <code>NUM</code>, <code>VAR</code>, <code>FNCT</code>, 
  and <code>exp</code>. Their declarations are augmented with information about 
  their data type (placed between angle brackets). The Bison construct 
  <code>%type</code> is used for declaring nonterminal symbols, just as 
  <code>%token</code> is used for declaring token types. We have not used 
  <code>%type</code> before because nonterminal symbols are normally declared 
  implicitly by the rules that define them. But <code>exp</code> must be 
  declared explicitly so we can specify its value type. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
  Symbols</a>. 
  <h3><a name=SEC31 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC31">Grammar 
  Rules for <code>mfcalc</code></a></h3>
  <p>Here are the grammar rules for the multi-function calculator. Most of them 
  are copied directly from <code>calc</code>; three rules, those which mention 
  <code>VAR</code> or <code>FNCT</code>, are new. <pre>input:   /* empty */
        | input line
;
line:
          '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;
exp:      NUM                { $$ = $1;                         }
        | VAR                { $$ = $1-&gt;value.var;              }
        | VAR '=' exp        { $$ = $3; $1-&gt;value.var = $3;     }
        | FNCT '(' exp ')'   { $$ = (*($1-&gt;value.fnctptr))($3); }
        | exp '+' exp        { $$ = $1 + $3;                    }
        | exp '-' exp        { $$ = $1 - $3;                    }
        | exp '*' exp        { $$ = $1 * $3;                    }
        | exp '/' exp        { $$ = $1 / $3;                    }
        | '-' exp  %prec NEG { $$ = -$2;                        }
        | exp '^' exp        { $$ = pow ($1, $3);               }
        | '(' exp ')'        { $$ = $2;                         }
;
/* End of grammar */
%%
</pre>
  <p>
  <h3><a name=SEC32 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC32">The 
  <code>mfcalc</code> Symbol Table</a></h3>
  <p><a name=IDX48></a>The multi-function calculator requires a symbol table to 
  keep track of the names and meanings of variables and functions. This doesn't 
  affect the grammar rules (except for the actions) or the Bison declarations, 
  but it requires some additional C functions for support. The symbol table 
  itself consists of a linked list of records. Its definition, which is kept in 
  the header <tt>`calc.h'</tt>, is as follows. It provides for either functions 
  or variables to be placed in the table. <pre>/* Data type for links in the chain of symbols.      */
struct symrec
{
  char *name;  /* name of symbol                     */
  int type;    /* type of symbol: either VAR or FNCT */
  union {
    double var;           /* value of a VAR          */
    double (*fnctptr)();  /* value of a FNCT         */
  } value;
  struct symrec *next;    /* link field              */
};
typedef struct symrec symrec;
/* The symbol table: a chain of `struct symrec'.     */
extern symrec *sym_table;
symrec *putsym ();
symrec *getsym ();
</pre>
  <p>The new version of <code>main</code> includes a call to 
  <code>init_table</code>, a function that initializes the symbol table. Here it 
  is, and <code>init_table</code> as well: <pre>#include &lt;stdio.h&gt;
main ()
{
  init_table ();
  yyparse ();
}
yyerror (s)  /* Called by yyparse on error */
     char *s;
{
  printf ("%s\n", s);
}
struct init
{
  char *fname;
  double (*fnct)();
};
struct init arith_fncts[]
  = {
      "sin", sin,
      "cos", cos,
      "atan", atan,
      "ln", log,
      "exp", exp,
      "sqrt", sqrt,
      0, 0
    };
/* The symbol table: a chain of `struct symrec'.  */
symrec *sym_table = (symrec *)0;
init_table ()  /* puts arithmetic functions in table. */
{
  int i;
  symrec *ptr;
  for (i = 0; arith_fncts[i].fname != 0; i++)
    {
      ptr = putsym (arith_fncts[i].fname, FNCT);
      ptr-&gt;value.fnctptr = arith_fncts[i].fnct;
    }
}
</pre>
  <p>By simply editing the initialization list and adding the necessary include 
  files, you can add additional functions to the calculator. Two important 
  functions allow look-up and installation of symbols in the symbol table. The 
  function <code>putsym</code> is passed a name and the type (<code>VAR</code> 
  or <code>FNCT</code>) of the object to be installed. The object is linked to 
  the front of the list, and a pointer to the object is returned. The function 
  <code>getsym</code> is passed the name of the symbol to look up. If found, a 
  pointer to that symbol is returned; otherwise zero is returned. <pre>symrec *
putsym (sym_name,sym_type)
     char *sym_name;
     int sym_type;
{
  symrec *ptr;
  ptr = (symrec *) malloc (sizeof (symrec));
  ptr-&gt;name = (char *) malloc (strlen (sym_name) + 1);
  strcpy (ptr-&gt;name,sym_name);
  ptr-&gt;type = sym_type;
  ptr-&gt;value.var = 0; /* set value to 0 even if fctn.  */
  ptr-&gt;next = (struct symrec *)sym_table;
  sym_table = ptr;
  return ptr;
}
symrec *
getsym (sym_name)
     char *sym_name;
{
  symrec *ptr;
  for (ptr = sym_table; ptr != (symrec *) 0;
       ptr = (symrec *)ptr-&gt;next)
    if (strcmp (ptr-&gt;name,sym_name) == 0)
      return ptr;
  return 0;
}
</pre>
  <p>The function <code>yylex</code> must now recognize variables, numeric 
  values, and the single-character arithmetic operators. Strings of alphanumeric 
  characters with a leading nondigit are recognized as either variables or 
  functions depending on what the symbol table says about them. The string is 
  passed to <code>getsym</code> for look up in the symbol table. If the name 
  appears in the table, a pointer to its location and its type (<code>VAR</code> 
  or <code>FNCT</code>) is returned to <code>yyparse</code>. If it is not 
  already in the table, then it is installed as a <code>VAR</code> using 
  <code>putsym</code>. Again, a pointer and its type (which must be 
  <code>VAR</code>) is returned to <code>yyparse</code>. No change is needed in 
  the handling of numeric values and arithmetic operators in <code>yylex</code>. 
<pre>#include &lt;ctype.h&gt;
yylex ()
{
  int c;
  /* Ignore whitespace, get first nonwhite character.  */
  while ((c = getchar ()) == ' ' || c == '\t');
  if (c == EOF)
    return 0;
  /* Char starts a number =&gt; parse the number.         */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &amp;yylval.val);
      return NUM;
    }
  /* Char starts an identifier =&gt; read the name.       */
  if (isalpha (c))
    {
      symrec *s;
      static char *symbuf = 0;
      static int length = 0;
      int i;
      /* Initially make the buffer long enough
         for a 40-character symbol name.  */
      if (length == 0)
        length = 40, symbuf = (char *)malloc (length + 1);
      i = 0;
      do
        {
          /* If buffer is full, make it bigger.        */
          if (i == length)
            {
              length *= 2;
              symbuf = (char *)realloc (symbuf, length + 1);
            }
          /* Add this character to the buffer.         */
          symbuf[i++] = c;
          /* Get another character.                    */
          c = getchar ();
        }
      while (c != EOF &amp;&amp; isalnum (c));
      ungetc (c, stdin);
      symbuf[i] = '\0';
      s = getsym (symbuf);
      if (s == 0)
        s = putsym (symbuf, VAR);
      yylval.tptr = s;
      return s-&gt;type;
    }
  /* Any other character is a token by itself.        */
  return c;
}
</pre>
  <p>This program is both powerful and flexible. You may easily add new 
  functions, and it is a simple job to modify this code to install predefined 
  variables such as <code>pi</code> or <code>e</code> as well. 
  <h2><a name=SEC33 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC33">Exercises</a></h2>
  <p><a name=IDX49></a>
  <ol>
    <li>Add some new functions from <tt>`math.h'</tt> to the initialization 
    list. 
    <li>Add another array that contains constants and their values. Then modify 
    <code>init_table</code> to add these constants to the symbol table. It will 
    be easiest to give the constants type <code>VAR</code>. 
    <li>Make the program report an error if the user refers to an uninitialized 
    variable in any way except to store a value in it. </li></ol>
  <p>
  <h1><a name=SEC34 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC34">Bison 
  Grammar Files</a></h1>
  <p>Bison takes as input a context-free grammar specification and produces a 
  C-language function that recognizes correct instances of the grammar. The 
  Bison grammar input file conventionally has a name ending in 
  <samp>`.y'</samp>. 
  <h2><a name=SEC35 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC35">Outline of 
  a Bison Grammar</a></h2>
  <p>A Bison grammar file has four main sections, shown here with the 
  appropriate delimiters: <pre>%{
<var>C declarations</var>
%}
<var>Bison declarations</var>
%%
<var>Grammar rules</var>
%%
<var>Additional C code</var>
</pre>
  <p>Comments enclosed in <samp>`/* ... */'</samp> may appear in any of the 
  sections. 
  <h3><a name=SEC36 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC36">The C 
  Declarations Section</a></h3>
  <p><a name=IDX50></a><a name=IDX51></a>The <var>C declarations</var> section 
  contains macro definitions and declarations of functions and variables that 
  are used in the actions in the grammar rules. These are copied to the 
  beginning of the parser file so that they precede the definition of 
  <code>yyparse</code>. You can use <samp>`#include'</samp> to get the 
  declarations from a header file. If you don't need any C declarations, you may 
  omit the <samp>`%{'</samp> and <samp>`%}'</samp> delimiters that bracket this 
  section. 
  <h3><a name=SEC37 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC37">The Bison 
  Declarations Section</a></h3>
  <p><a name=IDX52></a><a name=IDX53></a>The <var>Bison declarations</var> 
  section contains declarations that define terminal and nonterminal symbols, 
  specify precedence, and so on. In some simple grammars you may not need any 
  declarations. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC49">Bison 
  Declarations</a>. 
  <h3><a name=SEC38 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC38">The Grammar 
  Rules Section</a></h3>
  <p><a name=IDX54></a><a name=IDX55></a>The <em>grammar rules</em> section 
  contains one or more Bison grammar rules, and nothing else. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax of 
  Grammar Rules</a>. There must always be at least one grammar rule, and the 
  first <samp>`%%'</samp> (which precedes the grammar rules) may never be 
  omitted even if it is the first thing in the file. 
  <h3><a name=SEC39 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC39">The 
  Additional C Code Section</a></h3>
  <p><a name=IDX56></a><a name=IDX57></a>The <var>additional C code</var> 
  section is copied verbatim to the end of the parser file, just as the <var>C 
  declarations</var> section is copied to the beginning. This is the most 
  convenient place to put anything that you want to have in the parser file but 
  which need not come before the definition of <code>yyparse</code>. For 
  example, the definitions of <code>yylex</code> and <code>yyerror</code> often 
  go here. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC59">Parser 
  C-Language Interface</a>. If the last section is empty, you may omit the 
  <samp>`%%'</samp> that separates it from the grammar rules. The Bison parser 
  itself contains many static variables whose names start with <samp>`yy'</samp> 
  and many macros whose names start with <samp>`YY'</samp>. It is a good idea to 
  avoid using any such names (except those documented in this manual) in the 
  additional C code section of the grammar file. 
  <h2><a name=SEC40 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC40">Symbols, 
  Terminal and Nonterminal</a></h2>
  <p><a name=IDX58></a><a name=IDX59></a><a name=IDX60></a><a 
  name=IDX61></a><em>Symbols</em> in Bison grammars represent the grammatical 
  classifications of the language. A <em>terminal symbol</em> (also known as a 
  <em>token type</em>) represents a class of syntactically equivalent tokens. 
  You use the symbol in grammar rules to mean that a token in that class is 
  allowed. The symbol is represented in the Bison parser by a numeric code, and 
  the <code>yylex</code> function returns a token type code to indicate what 
  kind of token has been read. You don't need to know what the code value is; 
  you can use the symbol to stand for it. A <em>nonterminal symbol</em> stands 
  for a class of syntactically equivalent groupings. The symbol name is used in 
  writing grammar rules. By convention, it should be all lower case. Symbol 
  names can contain letters, digits (not at the beginning), underscores and 
  periods. Periods make sense only in nonterminals. There are two ways of 
  writing terminal symbols in the grammar: 
  <ul>
    <li>A <em>named token type</em> is written with an identifier, like an 
    identifier in C. By convention, it should be all upper case. Each such name 
    must be defined with a Bison declaration such as <code>%token</code>. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC50">Token 
    Type Names</a>. 
    <li><a name=IDX62></a><a name=IDX63></a><a name=IDX64></a>A <em>character 
    token type</em> (or <em>literal token</em>) is written in the grammar using 
    the same syntax used in C for character constants; for example, 
    <code>'+'</code> is a character token type. A character token type doesn't 
    need to be declared unless you need to specify its semantic value data type 
    (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC44">Data 
    Types of Semantic Values</a>), associativity, or precedence (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
    Precedence</a>). By convention, a character token type is used only to 
    represent a token that consists of that particular character. Thus, the 
    token type <code>'+'</code> is used to represent the character 
    <samp>`+'</samp> as a token. Nothing enforces this convention, but if you 
    depart from it, your program will confuse other readers. All the usual 
    escape sequences used in character literals in C can be used in Bison as 
    well, but you must not use the null character as a character literal because 
    its ASCII code, zero, is the code <code>yylex</code> returns for 
    end-of-input (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC62">Calling 
    Convention for <code>yylex</code></a>). </li></ul>
  <p>How you choose to write a terminal symbol has no effect on its grammatical 
  meaning. That depends only on where it appears in rules and on when the parser 
  function returns that symbol. The value returned by <code>yylex</code> is 
  always one of the terminal symbols (or 0 for end-of-input). Whichever way you 
  write the token type in the grammar rules, you write it the same way in the 
  definition of <code>yylex</code>. The numeric code for a character token type 
  is simply the ASCII code for the character, so <code>yylex</code> can use the 
  identical character constant to generate the requisite code. Each named token 
  type becomes a C macro in the parser file, so <code>yylex</code> can use the 
  name to stand for the code. (This is why periods don't make sense in terminal 
  symbols.) See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC62">Calling 
  Convention for <code>yylex</code></a>. If <code>yylex</code> is defined in a 
  separate file, you need to arrange for the token-type macro definitions to be 
  available there. Use the <samp>`-d'</samp> option when you run Bison, so that 
  it will write these macro definitions into a separate header file 
  <tt>`<var>name</var>.tab.h'</tt> which you can include in the other source 
  files that need it. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>. The symbol <code>error</code> is a terminal symbol reserved for 
  error recovery (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>); you shouldn't use it for any other purpose. In particular, 
  <code>yylex</code> should never return this value. 
  <h2><a name=SEC41 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC41">Syntax of 
  Grammar Rules</a></h2>
  <p><a name=IDX65></a><a name=IDX66></a><a name=IDX67></a>A Bison grammar rule 
  has the following general form: <pre><var>result</var>: <var>components</var>...
        ;
</pre>
  <p>where <var>result</var> is the nonterminal symbol that this rule describes 
  and <var>components</var> are various terminal and nonterminal symbols that 
  are put together by this rule (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
  Terminal and Nonterminal</a>). For example, <pre>exp:      exp '+' exp
        ;
</pre>
  <p>says that two groupings of type <code>exp</code>, with a <samp>`+'</samp> 
  token in between, can be combined into a larger grouping of type 
  <code>exp</code>. Whitespace in rules is significant only to separate symbols. 
  You can add extra whitespace as you wish. Scattered among the components can 
  be <var>actions</var> that determine the semantics of the rule. An action 
  looks like this: <pre>{<var>C statements</var>}
</pre>
  <p>Usually there is only one action and it follows the components. See section 
  <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 
  <a name=IDX68></a>Multiple rules for the same <var>result</var> can be written 
  separately or can be joined with the vertical-bar character <samp>`|'</samp> 
  as follows: <pre><var>result</var>:    <var>rule1-components</var>...
        | <var>rule2-components</var>...
        ...
        ;
</pre>
  <p>They are still considered distinct rules even when joined in this way. If 
  <var>components</var> in a rule is empty, it means that <var>result</var> can 
  match the empty string. For example, here is how to define a comma-separated 
  sequence of zero or more <code>exp</code> groupings: <pre>expseq:   /* empty */
        | expseq1
        ;
expseq1:  exp
        | expseq1 ',' exp
        ;
</pre>
  <p>It is customary to write a comment <samp>`/* empty */'</samp> in each rule 
  with no components. 
  <h2><a name=SEC42 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC42">Recursive 
  Rules</a></h2>
  <p><a name=IDX69></a>A rule is called <em>recursive</em> when its 
  <var>result</var> nonterminal appears also on its right hand side. Nearly all 
  Bison grammars need to use recursion, because that is the only way to define a 
  sequence of any number of somethings. Consider this recursive definition of a 
  comma-separated sequence of one or more expressions: <pre>expseq1:  exp
        | expseq1 ',' exp
        ;
</pre>
  <p><a name=IDX70></a><a name=IDX71></a>Since the recursive use of 
  <code>expseq1</code> is the leftmost symbol in the right hand side, we call 
  this <em>left recursion</em>. By contrast, here the same construct is defined 
  using <em>right recursion</em>: <pre>expseq1:  exp
        | exp ',' expseq1
        ;
</pre>
  <p>Any kind of sequence can be defined using either left recursion or right 
  recursion, but you should always use left recursion, because it can parse a 
  sequence of any number of elements with bounded stack space. Right recursion 
  uses up space on the Bison stack in proportion to the number of elements in 
  the sequence, because all the elements must be shifted onto the stack before 
  the rule can be applied even once. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
  Parser Algorithm</a>, for further explanation of this. <a 
  name=IDX72></a><em>Indirect</em> or <em>mutual</em> recursion occurs when the 
  result of the rule does not appear directly on its right hand side, but does 
  appear in rules for other nonterminals which do appear on its right hand side. 
  For example: <pre>expr:     primary
        | primary '+' primary
        ;
primary:  constant
        | '(' expr ')'
        ;
</pre>
  <p>defines two mutually-recursive nonterminals, since each refers to the 
  other. 
  <h2><a name=SEC43 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC43">Defining 
  Language Semantics</a></h2>
  <p><a name=IDX73></a><a name=IDX74></a>The grammar rules for a language 
  determine only the syntax. The semantics are determined by the semantic values 
  associated with various tokens and groupings, and by the actions taken when 
  various groupings are recognized. For example, the calculator calculates 
  properly because the value associated with each expression is the proper 
  number; it adds properly because the action for the grouping 
  <samp>`<var>x</var> + <var>y</var>'</samp> is to add the numbers associated 
  with <var>x</var> and <var>y</var>. 
  <h3><a name=SEC44 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC44">Data Types 
  of Semantic Values</a></h3>
  <p><a name=IDX75></a><a name=IDX76></a><a name=IDX77></a><a name=IDX78></a>In 
  a simple program it may be sufficient to use the same data type for the 
  semantic values of all language constructs. This was true in the RPN and infix 
  calculator examples (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC16">Reverse 
  Polish Notation Calculator</a>). Bison's default is to use type 
  <code>int</code> for all semantic values. To specify some other type, define 
  <code>YYSTYPE</code> as a macro, like this: <pre>#define YYSTYPE double
</pre>
  <p>This macro definition must go in the C declarations section of the grammar 
  file (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC35">Outline of 
  a Bison Grammar</a>). 
  <h3><a name=SEC45 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC45">More Than 
  One Value Type</a></h3>
  <p>In most programs, you will need different data types for different kinds of 
  tokens and groupings. For example, a numeric constant may need type 
  <code>int</code> or <code>long</code>, while a string constant needs type 
  <code>char *</code>, and an identifier might need a pointer to an entry in the 
  symbol table. To use more than one data type for semantic values in one 
  parser, Bison requires you to do two things: 
  <ul>
    <li>Specify the entire collection of possible data types, with the 
    <code>%union</code> Bison declaration (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
    Collection of Value Types</a>). 
    <li>Choose one of those types for each symbol (terminal or nonterminal) for 
    which semantic values are used. This is done for tokens with the 
    <code>%token</code> Bison declaration (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC50">Token 
    Type Names</a>) and for groupings with the <code>%type</code> Bison 
    declaration (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
    Symbols</a>). </li></ul>
  <p>
  <h3><a name=SEC46 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC46">Actions</a></h3>
  <p><a name=IDX79></a><a name=IDX80></a><a name=IDX81></a>An action accompanies 
  a syntactic rule and contains C code to be executed each time an instance of 
  that rule is recognized. The task of most actions is to compute a semantic 
  value for the grouping built by the rule from the semantic values associated 
  with tokens or smaller groupings. An action consists of C statements 
  surrounded by braces, much like a compound statement in C. It can be placed at 
  any position in the rule; it is executed at that position. Most rules have 
  just one action at the end of the rule, following all the components. Actions 
  in the middle of a rule are tricky and used only for special purposes (see 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC48">Actions in 
  Mid-Rule</a>). The C code in an action can refer to the semantic values of the 
  components matched by the rule with the construct <code>$<VAR>n</VAR></code>, 
  which stands for the value of the <var>n</var>th component. The semantic value 
  for the grouping being constructed is <code>$$</code>. (Bison translates both 
  of these constructs into array element references when it copies the actions 
  into the parser file.) Here is a typical example: <pre>exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</pre>
  <p>This rule constructs an <code>exp</code> from two smaller <code>exp</code> 
  groupings connected by a plus-sign token. In the action, <code>$1</code> and 
  <code>$3</code> refer to the semantic values of the two component 
  <code>exp</code> groupings, which are the first and third symbols on the right 
  hand side of the rule. The sum is stored into <code>$$</code> so that it 
  becomes the semantic value of the addition-expression just recognized by the 
  rule. If there were a useful semantic value associated with the 
  <samp>`+'</samp> token, it could be referred to as <code>$2</code>. <a 
  name=IDX82></a>If you don't specify an action for a rule, Bison supplies a 
  default: <code>$$ = $1</code>. Thus, the value of the first symbol in the rule 
  becomes the value of the whole rule. Of course, the default rule is valid only 
  if the two data types match. There is no meaningful default action for an 
  empty rule; every empty rule must have an explicit action unless the rule's 
  value does not matter. <code>$<VAR>n</VAR></code> with <var>n</var> zero or 
  negative is allowed for reference to tokens and groupings on the stack 
  <em>before</em> those that match the current rule. This is a very risky 
  practice, and to use it reliably you must be certain of the context in which 
  the rule is applied. Here is a case in which you can use this reliably: <pre>foo:      expr bar '+' expr  { ... }
        | expr bar '-' expr  { ... }
        ;
bar:      /* empty */
        { previous_expr = $0; }
        ;
</pre>
  <p>As long as <code>bar</code> is used only in the fashion shown here, 
  <code>$0</code> always refers to the <code>expr</code> which precedes 
  <code>bar</code> in the definition of <code>foo</code>. 
  <h3><a name=SEC47 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC47">Data Types 
  of Values in Actions</a></h3>
  <p><a name=IDX83></a><a name=IDX84></a>If you have chosen a single data type 
  for semantic values, the <code>$$</code> and <code>$<VAR>n</VAR></code> 
  constructs always have that data type. If you have used <code>%union</code> to 
  specify a variety of data types, then you must declare a choice among these 
  types for each terminal or nonterminal symbol that can have a semantic value. 
  Then each time you use <code>$$</code> or <code>$<VAR>n</VAR></code>, its data 
  type is determined by which symbol it refers to in the rule. In this example, <pre>exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</pre>
  <p><code>$1</code> and <code>$3</code> refer to instances of <code>exp</code>, 
  so they all have the data type declared for the nonterminal symbol 
  <code>exp</code>. If <code>$2</code> were used, it would have the data type 
  declared for the terminal symbol <code>'+'</code>, whatever that might be. 
  Alternatively, you can specify the data type when you refer to the value, by 
  inserting <samp>`&lt;<var>type</var>&gt;'</samp> after the <samp>`$'</samp> at 
  the beginning of the reference. For example, if you have defined types as 
  shown here: <pre>%union {
  int itype;
  double dtype;
}
</pre>
  <p>then you can write <code>$&lt;itype&gt;1</code> to refer to the first 
  subunit of the rule as an integer, or <code>$&lt;dtype&gt;1</code> to refer to 
  it as a double. 
  <h3><a name=SEC48 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC48">Actions in 
  Mid-Rule</a></h3>
  <p><a name=IDX85></a><a name=IDX86></a>Occasionally it is useful to put an 
  action in the middle of a rule. These actions are written just like usual 
  end-of-rule actions, but they are executed before the parser even recognizes 
  the following components. A mid-rule action may refer to the components 
  preceding it using <code>$<VAR>n</VAR></code>, but it may not refer to 
  subsequent components because it is run before they are parsed. The mid-rule 
  action itself counts as one of the components of the rule. This makes a 
  difference when there is another action later in the same rule (and usually 
  there is another at the end): you have to count the actions along with the 
  symbols when working out which number <var>n</var> to use in 
  <code>$<VAR>n</VAR></code>. The mid-rule action can also have a semantic 
  value. The action can set its value with an assignment to <code>$$</code>, and 
  actions later in the rule can refer to the value using 
  <code>$<VAR>n</VAR></code>. Since there is no symbol to name the action, there 
  is no way to declare a data type for the value in advance, so you must use the 
  <samp>`$&lt;...&gt;'</samp> construct to specify a data type each time you 
  refer to this value. There is no way to set the value of the entire rule with 
  a mid-rule action, because assignments to <code>$$</code> do not have that 
  effect. The only way to set the value for the entire rule is with an ordinary 
  action at the end of the rule. Here is an example from a hypothetical 
  compiler, handling a <code>let</code> statement that looks like <samp>`let 
  (<var>variable</var>) <var>statement</var>'</samp> and serves to create a 
  variable named <var>variable</var> temporarily for the duration of 
  <var>statement</var>. To parse this construct, we must put <var>variable</var> 
  into the symbol table while <var>statement</var> is parsed, then remove it 
  afterward. Here is how it is done: <pre>stmt:   LET '(' var ')'
                { $&lt;context&gt;$ = push_context ();
                  declare_variable ($3); }
        stmt    { $$ = $6;
                  pop_context ($&lt;context&gt;5); }
</pre>
  <p>As soon as <samp>`let (<var>variable</var>)'</samp> has been recognized, 
  the first action is run. It saves a copy of the current semantic context (the 
  list of accessible variables) as its semantic value, using alternative 
  <code>context</code> in the data-type union. Then it calls 
  <code>declare_variable</code> to add the new variable to that list. Once the 
  first action is finished, the embedded statement <code>stmt</code> can be 
  parsed. Note that the mid-rule action is component number 5, so the 
  <samp>`stmt'</samp> is component number 6. After the embedded statement is 
  parsed, its semantic value becomes the value of the entire 
  <code>let</code>-statement. Then the semantic value from the earlier action is 
  used to restore the prior list of variables. This removes the temporary 
  <code>let</code>-variable from the list so that it won't appear to exist while 
  the rest of the program is parsed. Taking action before a rule is completely 
  recognized often leads to conflicts since the parser must commit to a parse in 
  order to execute the action. For example, the following two rules, without 
  mid-rule actions, can coexist in a working parser because the parser can shift 
  the open-brace token and look at what follows before deciding whether there is 
  a declaration or not: <pre>compound: '{' declarations statements '}'
        | '{' statements '}'
        ;
</pre>
  <p>But when we add a mid-rule action as follows, the rules become 
  nonfunctional: <pre>compound: { prepare_for_local_variables (); }
          '{' declarations statements '}'
        | '{' statements '}'
        ;
</pre>
  <p>Now the parser is forced to decide whether to run the mid-rule action when 
  it has read no farther than the open-brace. In other words, it must commit to 
  using one rule or the other, without sufficient information to do it 
  correctly. (The open-brace token is what is called the <em>look-ahead</em> 
  token at this time, since the parser is still deciding what to do about it. 
  See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC69">Look-Ahead 
  Tokens</a>.) You might think that you could correct the problem by putting 
  identical actions into the two rules, like this: <pre>compound: { prepare_for_local_variables (); }
          '{' declarations statements '}'
        | { prepare_for_local_variables (); }
          '{' statements '}'
        ;
</pre>
  <p>But this does not help, because Bison does not realize that the two actions 
  are identical. (Bison never tries to understand the C code in an action.) If 
  the grammar is such that a declaration can be distinguished from a statement 
  by the first token (which is true in C), then one solution which does work is 
  to put the action after the open-brace, like this: <pre>compound: '{' { prepare_for_local_variables (); }
          declarations statements '}'
        | '{' statements '}'
        ;
</pre>
  <p>Now the first token of the following declaration or statement, which would 
  in any case tell Bison which rule to use, can still do so. Another solution is 
  to bury the action inside a nonterminal symbol which serves as a subroutine: <pre>subroutine: /* empty */
          { prepare_for_local_variables (); }
        ;
compound: subroutine
          '{' declarations statements '}'
        | subroutine
          '{' statements '}'
        ;
</pre>
  <p>Now Bison can execute the action in the rule for <code>subroutine</code> 
  without deciding which rule for <code>compound</code> it will eventually use. 
  Note that the action is now at the end of its rule. Any mid-rule action can be 
  converted to an end-of-rule action in this way, and this is what Bison 
  actually does to implement mid-rule actions. 
  <h2><a name=SEC49 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC49">Bison 
  Declarations</a></h2>
  <p><a name=IDX87></a><a name=IDX88></a>The <em>Bison declarations</em> section 
  of a Bison grammar defines the symbols used in formulating the grammar and the 
  data types of semantic values. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
  Terminal and Nonterminal</a>. All token type names (but not single-character 
  literal tokens such as <code>'+'</code> and <code>'*'</code>) must be 
  declared. Nonterminal symbols must be declared if you need to specify which 
  data type to use for the semantic value (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC45">More Than 
  One Value Type</a>). The first rule in the file also specifies the start 
  symbol, by default. If you want some other symbol to be the start symbol, you 
  must declare it explicitly (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
  and Context-Free Grammars</a>). 
  <h3><a name=SEC50 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC50">Token Type 
  Names</a></h3>
  <p><a name=IDX89></a><a name=IDX90></a><a name=IDX91></a>The basic way to 
  declare a token type name (terminal symbol) is as follows: <pre>%token <var>name</var>
</pre>
  <p>Bison will convert this into a <code>#define</code> directive in the 
  parser, so that the function <code>yylex</code> (if it is in this file) can 
  use the name <var>name</var> to stand for this token type's code. 
  Alternatively, you can use <code>%left</code>, <code>%right</code>, or 
  <code>%nonassoc</code> instead of <code>%token</code>, if you wish to specify 
  precedence. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
  Precedence</a>. You can explicitly specify the numeric code for a token type 
  by appending an integer value in the field immediately following the token 
  name: <pre>%token NUM 300
</pre>
  <p>It is generally best, however, to let Bison choose the numeric codes for 
  all token types. Bison will automatically select codes that don't conflict 
  with each other or with ASCII characters. In the event that the stack type is 
  a union, you must augment the <code>%token</code> or other token declaration 
  to include the data type alternative delimited by angle-brackets (see section 
  <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC45">More 
  Than One Value Type</a>). For example: <pre>%union {              /* define stack type */
  double val;
  symrec *tptr;
}
%token &lt;val&gt; NUM      /* define token NUM and its type */
</pre>
  <p>
  <h3><a name=SEC51 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC51">Operator 
  Precedence</a></h3>
  <p><a name=IDX92></a><a name=IDX93></a><a name=IDX94></a>Use the 
  <code>%left</code>, <code>%right</code> or <code>%nonassoc</code> declaration 
  to declare a token and specify its precedence and associativity, all at once. 
  These are called <em>precedence declarations</em>. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
  Precedence</a>, for general information on operator precedence. The syntax of 
  a precedence declaration is the same as that of <code>%token</code>: either <pre>%left <var>symbols</var>...
</pre>
  <p>or <pre>%left &lt;<var>type</var>&gt; <var>symbols</var>...
</pre>
  <p>And indeed any of these declarations serves the purposes of 
  <code>%token</code>. But in addition, they specify the associativity and 
  relative precedence for all the <var>symbols</var>: 
  <ul>
    <li>The associativity of an operator <var>op</var> determines how repeated 
    uses of the operator nest: whether <samp>`<var>x</var> <var>op</var> 
    <var>y</var> <var>op</var> <var>z</var>'</samp> is parsed by grouping 
    <var>x</var> with <var>y</var> first or by grouping <var>y</var> with 
    <var>z</var> first. <code>%left</code> specifies left-associativity 
    (grouping <var>x</var> with <var>y</var> first) and <code>%right</code> 
    specifies right-associativity (grouping <var>y</var> with <var>z</var> 
    first). <code>%nonassoc</code> specifies no associativity, which means that 
    <samp>`<var>x</var> <var>op</var> <var>y</var> <var>op</var> 
    <var>z</var>'</samp> is considered a syntax error. 
    <li>The precedence of an operator determines how it nests with other 
    operators. All the tokens declared in a single precedence declaration have 
    equal precedence and nest together according to their associativity. When 
    two tokens declared in different precedence declarations associate, the one 
    declared later has the higher precedence and is grouped first. </li></ul>
  <p>
  <h3><a name=SEC52 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC52">The 
  Collection of Value Types</a></h3>
  <p><a name=IDX95></a><a name=IDX96></a><a name=IDX97></a>The 
  <code>%union</code> declaration specifies the entire collection of possible 
  data types for semantic values. The keyword <code>%union</code> is followed by 
  a pair of braces containing the same thing that goes inside a 
  <code>union</code> in C. For example: <pre>%union {
  double val;
  symrec *tptr;
}
</pre>
  <p>This says that the two alternative types are <code>double</code> and 
  <code>symrec *</code>. They are given names <code>val</code> and 
  <code>tptr</code>; these names are used in the <code>%token</code> and 
  <code>%type</code> declarations to pick one of the types for a terminal or 
  nonterminal symbol (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
  Symbols</a>). Note that, unlike making a <code>union</code> declaration in C, 
  you do not write a semicolon after the closing brace. 
  <h3><a name=SEC53 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC53">Nonterminal 
  Symbols</a></h3>
  <p><a name=IDX98></a><a name=IDX99></a><a name=IDX100></a>When you use 
  <code>%union</code> to specify multiple value types, you must declare the 
  value type of each nonterminal symbol for which values are used. This is done 
  with a <code>%type</code> declaration, like this: <pre>%type &lt;<var>type</var>&gt; <var>nonterminal</var>...
</pre>
  <p>Here <var>nonterminal</var> is the name of a nonterminal symbol, and 
  <var>type</var> is the name given in the <code>%union</code> to the 
  alternative that you want (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
  Collection of Value Types</a>). You can give any number of nonterminal symbols 
  in the same <code>%type</code> declaration, if they have the same value type. 
  Use spaces to separate the symbol names. 
  <h3><a name=SEC54 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC54">Suppressing 
  Conflict Warnings</a></h3>
  <p><a name=IDX101></a><a name=IDX102></a><a name=IDX103></a><a 
  name=IDX104></a><a name=IDX105></a>Bison normally warns if there are any 
  conflicts in the grammar (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC70">Shift/Reduce 
  Conflicts</a>), but most real grammars have harmless shift/reduce conflicts 
  which are resolved in a predictable way and would be difficult to eliminate. 
  It is desirable to suppress the warning about these conflicts unless the 
  number of conflicts changes. You can do this with the <code>%expect</code> 
  declaration. The declaration looks like this: <pre>%expect <var>n</var>
</pre>
  <p>Here <var>n</var> is a decimal integer. The declaration says there should 
  be no warning if there are <var>n</var> shift/reduce conflicts and no 
  reduce/reduce conflicts. The usual warning is given if there are either more 
  or fewer conflicts, or if there are any reduce/reduce conflicts. In general, 
  using <code>%expect</code> involves these steps: 
  <ul>
    <li>Compile your grammar without <code>%expect</code>. Use the 
    <samp>`-v'</samp> option to get a verbose list of where the conflicts occur. 
    Bison will also print the number of conflicts. 
    <li>Check each of the conflicts to make sure that Bison's default resolution 
    is what you really want. If not, rewrite the grammar and go back to the 
    beginning. 
    <li>Add an <code>%expect</code> declaration, copying the number <var>n</var> 
    from the number which Bison printed. </li></ul>
  <p>Now Bison will stop annoying you about the conflicts you have checked, but 
  it will warn you again if changes in the grammar result in additional 
  conflicts. 
  <h3><a name=SEC55 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC55">The 
  Start-Symbol</a></h3>
  <p><a name=IDX106></a><a name=IDX107></a><a name=IDX108></a><a 
  name=IDX109></a>Bison assumes by default that the start symbol for the grammar 
  is the first nonterminal specified in the grammar specification section. The 
  programmer may override this restriction with the <code>%start</code> 
  declaration as follows: <pre>%start <var>symbol</var>
</pre>
  <p>
  <h3><a name=SEC56 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC56">A Pure 
  (Reentrant) Parser</a></h3>
  <p><a name=IDX110></a><a name=IDX111></a><a name=IDX112></a>A 
  <em>reentrant</em> program is one which does not alter in the course of 
  execution; in other words, it consists entirely of <em>pure</em> (read-only) 
  code. Reentrancy is important whenever asynchronous execution is possible; for 
  example, a nonreentrant program may not be safe to call from a signal handler. 
  In systems with multiple threads of control, a nonreentrant program must be 
  called only within interlocks. The Bison parser is not normally a reentrant 
  program, because it uses statically allocated variables for communication with 
  <code>yylex</code>. These variables include <code>yylval</code> and 
  <code>yylloc</code>. The Bison declaration <code>%pure_parser</code> says that 
  you want the parser to be reentrant. It looks like this: <pre>%pure_parser
</pre>
  <p>The effect is that the two communication variables become local variables 
  in <code>yyparse</code>, and a different calling convention is used for the 
  lexical analyzer function <code>yylex</code>. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC65">Calling 
  Conventions for Pure Parsers</a>, for the details of this. The variable 
  <code>yynerrs</code> also becomes local in <code>yyparse</code> (see section 
  <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC66">The 
  Error Reporting Function <code>yyerror</code></a>). The convention for calling 
  <code>yyparse</code> itself is unchanged. 
  <h3><a name=SEC57 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC57">Bison 
  Declaration Summary</a></h3>
  <p><a name=IDX113></a><a name=IDX114></a><a name=IDX115></a>Here is a summary 
  of all Bison declarations: 
  <dl compact>
    <dt><code>%union</code> 
    <dd>Declare the collection of data types that semantic values may have (see 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
    Collection of Value Types</a>). 
    <dt><code>%token</code> 
    <dd>Declare a terminal symbol (token type name) with no precedence or 
    associativity specified (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC50">Token 
    Type Names</a>). 
    <dt><code>%right</code> 
    <dd>Declare a terminal symbol (token type name) that is right-associative 
    (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>). 
    <dt><code>%left</code> 
    <dd>Declare a terminal symbol (token type name) that is left-associative 
    (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>). 
    <dt><code>%nonassoc</code> 
    <dd>Declare a terminal symbol (token type name) that is nonassociative 
    (using it in a way that would be associative is a syntax error) (see section 
    <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>). 
    <dt><code>%type</code> 
    <dd>Declare the type of semantic values for a nonterminal symbol (see 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
    Symbols</a>). 
    <dt><code>%start</code> 
    <dd>Specify the grammar's start symbol (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC55">The 
    Start-Symbol</a>). 
    <dt><code>%expect</code> 
    <dd>Declare the expected number of shift-reduce conflicts (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC54">Suppressing 
    Conflict Warnings</a>). 
    <dt><code>%pure_parser</code> 
    <dd>Request a pure (reentrant) parser program (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
    (Reentrant) Parser</a>). </dd></dl>
  <p>
  <h2><a name=SEC58 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC58">Multiple 
  Parsers in the Same Program</a></h2>
  <p>Most programs that use Bison parse only one language and therefore contain 
  only one Bison parser. But what if you want to parse more than one language 
  with the same program? Then you need to avoid a name conflict between 
  different definitions of <code>yyparse</code>, <code>yylval</code>, and so on. 
  The easy way to do this is to use the option <samp>`-p 
  <var>prefix</var>'</samp> (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>). This renames the interface functions and variables of the Bison 
  parser to start with <var>prefix</var> instead of <samp>`yy'</samp>. You can 
  use this to give each parser distinct names that do not conflict. The precise 
  list of symbols renamed is <code>yyparse</code>, <code>yylex</code>, 
  <code>yyerror</code>, <code>yynerrs</code>, <code>yylval</code>, 
  <code>yychar</code> and <code>yydebug</code>. For example, if you use 
  <samp>`-p c'</samp>, the names become <code>cparse</code>, <code>clex</code>, 
  and so on. <strong>All the other variables and macros associated with Bison 
  are not renamed.</strong> These others are not global; there is no conflict if 
  the same name is used in different parsers. For example, <code>YYSTYPE</code> 
  is not renamed, but defining this in different ways in different parsers 
  causes no trouble (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC44">Data Types 
  of Semantic Values</a>). The <samp>`-p'</samp> option works by adding macro 
  definitions to the beginning of the parser source file, defining 
  <code>yyparse</code> as <code><VAR>prefix</VAR>parse</code>, and so on. This 
  effectively substitutes one name for the other in the entire parser file. 
  <h1><a name=SEC59 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC59">Parser 
  C-Language Interface</a></h1>
  <p><a name=IDX116></a><a name=IDX117></a>The Bison parser is actually a C 
  function named <code>yyparse</code>. Here we describe the interface 
  conventions of <code>yyparse</code> and the other functions that it needs to 
  use. Keep in mind that the parser uses many C identifiers starting with 
  <samp>`yy'</samp> and <samp>`YY'</samp> for internal purposes. If you use such 
  an identifier (aside from those in this manual) in an action or in additional 
  C code in the grammar file, you are likely to run into trouble. 
  <h2><a name=SEC60 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC60">The Parser 
  Function <code>yyparse</code></a></h2>
  <p><a name=IDX118></a>You call the function <code>yyparse</code> to cause 
  parsing to occur. This function reads tokens, executes actions, and ultimately 
  returns when it encounters end-of-input or an unrecoverable syntax error. You 
  can also write an action which directs <code>yyparse</code> to return 
  immediately without reading further. The value returned by 
  <code>yyparse</code> is 0 if parsing was successful (return is due to 
  end-of-input). The value is 1 if parsing failed (return is due to a syntax 
  error). In an action, you can cause immediate return from <code>yyparse</code> 
  by using these macros: 
  <dl compact>
    <dt><code>YYACCEPT</code> 
    <dd><a name=IDX119></a>Return immediately with value 0 (to report success). 
    <dt><code>YYABORT</code> 
    <dd><a name=IDX120></a>Return immediately with value 1 (to report failure). 
    </dd></dl>
  <p>
  <h2><a name=SEC61 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC61">The Lexical 
  Analyzer Function <code>yylex</code></a></h2>
  <p><a name=IDX121></a><a name=IDX122></a>The <em>lexical analyzer</em> 
  function, <code>yylex</code>, recognizes tokens from the input stream and 
  returns them to the parser. Bison does not create this function automatically; 
  you must write it so that <code>yyparse</code> can call it. The function is 
  sometimes referred to as a lexical scanner. In simple programs, 
  <code>yylex</code> is often defined at the end of the Bison grammar file. If 
  <code>yylex</code> is defined in a separate source file, you need to arrange 
  for the token-type macro definitions to be available there. To do this, use 
  the <samp>`-d'</samp> option when you run Bison, so that it will write these 
  macro definitions into a separate header file <tt>`<var>name</var>.tab.h'</tt> 
  which you can include in the other source files that need it. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>. 
  <h3><a name=SEC62 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC62">Calling 
  Convention for <code>yylex</code></a></h3>
  <p>The value that <code>yylex</code> returns must be the numeric code for the 
  type of token it has just found, or 0 for end-of-input. When a token is 
  referred to in the grammar rules by a name, that name in the parser file 
  becomes a C macro whose definition is the proper numeric code for that token 
  type. So <code>yylex</code> can use the name to indicate that type. See 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
  Terminal and Nonterminal</a>. When a token is referred to in the grammar rules 
  by a character literal, the numeric code for that character is also the code 
  for the token type. So <code>yylex</code> can simply return that character 
  code. The null character must not be used this way, because its code is zero 
  and that is what signifies end-of-input. Here is an example showing these 
  things: <pre>yylex ()
{
  ...
  if (c == EOF)     /* Detect end of file. */
    return 0;
  ...
  if (c == '+' || c == '-')
    return c;      /* Assume token type for `+' is '+'. */
  ...
  return INT;      /* Return the type of the token. */
  ...
}
</pre>
  <p>This interface has been designed so that the output from the 
  <code>lex</code> utility can be used without change as the definition of 
  <code>yylex</code>. 
  <h3><a name=SEC63 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC63">Semantic 
  Values of Tokens</a></h3>
  <p><a name=IDX123></a>In an ordinary (nonreentrant) parser, the semantic value 
  of the token must be stored into the global variable <code>yylval</code>. When 
  you are using just one data type for semantic values, <code>yylval</code> has 
  that type. Thus, if the type is <code>int</code> (the default), you might 
  write this in <code>yylex</code>: <pre>  ...
  yylval = value;  /* Put value onto Bison stack. */
  return INT;      /* Return the type of the token. */
  ...
</pre>
  <p>When you are using multiple data types, <code>yylval</code>'s type is a 
  union made from the <code>%union</code> declaration (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
  Collection of Value Types</a>). So when you store a token's value, you must 
  use the proper member of the union. If the <code>%union</code> declaration 
  looks like this: <pre>%union {
  int intval;
  double val;
  symrec *tptr;
}
</pre>
  <p>then the code in <code>yylex</code> might look like this: <pre>  ...
  yylval.intval = value; /* Put value onto Bison stack. */
  return INT;          /* Return the type of the token. */
  ...
</pre>
  <p>
  <h3><a name=SEC64 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC64">Textual 
  Positions of Tokens</a></h3>
  <p><a name=IDX124></a>If you are using the 
  <samp>`@<var>n</var>'</samp>-feature (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
  Features for Use in Actions</a>) in actions to keep track of the textual 
  locations of tokens and groupings, then you must provide this information in 
  <code>yylex</code>. The function <code>yyparse</code> expects to find the 
  textual location of a token just parsed in the global variable 
  <code>yylloc</code>. So <code>yylex</code> must store the proper data in that 
  variable. The value of <code>yylloc</code> is a structure and you need only 
  initialize the members that are going to be used by the actions. The four 
  members are called <code>first_line</code>, <code>first_column</code>, 
  <code>last_line</code> and <code>last_column</code>. Note that the use of this 
  feature makes the parser noticeably slower. <a name=IDX125></a>The data type 
  of <code>yylloc</code> has the name <code>YYLTYPE</code>. 
  <h3><a name=SEC65 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC65">Calling 
  Conventions for Pure Parsers</a></h3>
  <p>When you use the Bison declaration <code>%pure_parser</code> to request a 
  pure, reentrant parser, the global communication variables <code>yylval</code> 
  and <code>yylloc</code> cannot be used. (See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
  (Reentrant) Parser</a>.) In such parsers the two global variables are replaced 
  by pointers passed as arguments to <code>yylex</code>. You must declare them 
  as shown here, and pass the information back by storing it through those 
  pointers. <pre>yylex (lvalp, llocp)
     YYSTYPE *lvalp;
     YYLTYPE *llocp;
{
  ...
  *lvalp = value;  /* Put value onto Bison stack.  */
  return INT;      /* Return the type of the token.  */
  ...
}
</pre>
  <p>If the grammar file does not use the <samp>`@'</samp> constructs to refer 
  to textual positions, then the type <code>YYLTYPE</code> will not be defined. 
  In this case, omit the second argument; <code>yylex</code> will be called with 
  only one argument. <a name=IDX126></a>You can pass parameter information to a 
  reentrant parser in a reentrant way. Define the macro 
  <code>YYPARSE_PARAM</code> as a variable name. The resulting 
  <code>yyparse</code> function then accepts one argument, of type <code>void 
  *</code>, with that name. When you call <code>yyparse</code>, pass the address 
  of an object, casting the address to <code>void *</code>. The grammar actions 
  can refer to the contents of the object by casting the pointer value back to 
  its proper type and then dereferencing it. Here's an example. Write this in 
  the parser: <pre>%{
struct parser_control
{
  int nastiness;
  int randomness;
};
#define YYPARSE_PARAM parm
%}
</pre>
  <p>Then call the parser like this: <pre>struct parser_control
{
  int nastiness;
  int randomness;
};
...
{
  struct parser_control foo;
  ...  /* Store proper data in <code>foo</code>.  */
  value = yyparse ((void *) &amp;foo);
  ...
}
</pre>
  <p>In the grammar actions, use expressions like this to refer to the data: <pre>((struct parser_control *) parm)-&gt;randomness
</pre>
  <p><a name=IDX127></a>If you wish to pass the additional parameter data to 
  <code>yylex</code>, define the macro <code>YYLEX_PARAM</code> just like 
  <code>YYPARSE_PARAM</code>, as shown here: <pre>%{
struct parser_control
{
  int nastiness;
  int randomness;
};
#define YYPARSE_PARAM parm
#define YYLEX_PARAM parm
%}
</pre>
  <p>You should then define <code>yylex</code> to accept one additional 
  argument--the value of <code>parm</code>. (This makes either two or three 
  arguments in total, depending on whether an argument of type 
  <code>YYLTYPE</code> is passed.) You can declare the argument as a pointer to 
  the proper object type, or you can declare it as <code>void *</code> and 
  access the contents as shown above. 
  <h2><a name=SEC66 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC66">The Error 
  Reporting Function <code>yyerror</code></a></h2>
  <p><a name=IDX128></a><a name=IDX129></a><a name=IDX130></a><a 
  name=IDX131></a>The Bison parser detects a <em>parse error</em> or <em>syntax 
  error</em> whenever it reads a token which cannot satisfy any syntax rule. A 
  action in the grammar can also explicitly proclaim an error, using the macro 
  <code>YYERROR</code> (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
  Features for Use in Actions</a>). The Bison parser expects to report the error 
  by calling an error reporting function named <code>yyerror</code>, which you 
  must supply. It is called by <code>yyparse</code> whenever a syntax error is 
  found, and it receives one argument. For a parse error, the string is normally 
  <code>"parse error"</code>. <a name=IDX132></a>If you define the macro 
  <code>YYERROR_VERBOSE</code> in the Bison declarations section (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC37">The Bison 
  Declarations Section</a>), then Bison provides a more verbose and specific 
  error message string instead of just plain <code>"parse error"</code>. It 
  doesn't matter what definition you use for <code>YYERROR_VERBOSE</code>, just 
  whether you define it. The parser can detect one other kind of error: stack 
  overflow. This happens when the input contains constructions that are very 
  deeply nested. It isn't likely you will encounter this, since the Bison parser 
  extends its stack automatically up to a very large limit. But if overflow 
  happens, <code>yyparse</code> calls <code>yyerror</code> in the usual fashion, 
  except that the argument string is <code>"parser stack overflow"</code>. The 
  following definition suffices in simple programs: <pre>yyerror (s)
     char *s;
{
  fprintf (stderr, "%s\n", s);
}
</pre>
  <p>After <code>yyerror</code> returns to <code>yyparse</code>, the latter will 
  attempt error recovery if you have written suitable error recovery grammar 
  rules (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>). If recovery is impossible, <code>yyparse</code> will 
  immediately return 1. <a name=IDX133></a>The variable <code>yynerrs</code> 
  contains the number of syntax errors encountered so far. Normally this 
  variable is global; but if you request a pure parser (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
  (Reentrant) Parser</a>) then it is a local variable which only the actions can 
  access. 
  <h2><a name=SEC67 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC67">Special 
  Features for Use in Actions</a></h2>
  <p><a name=IDX134></a><a name=IDX135></a>Here is a table of Bison constructs, 
  variables and macros that are useful in actions. 
  <dl compact>
    <dt><samp>`$$'</samp> 
    <dd>Acts like a variable that contains the semantic value for the grouping 
    made by the current rule. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 

    <dt><samp>`$<var>n</var>'</samp> 
    <dd>Acts like a variable that contains the semantic value for the 
    <var>n</var>th component of the current rule. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC46">Actions</a>. 

    <dt><samp>`$&lt;<var>typealt</var>&gt;$'</samp> 
    <dd>Like <code>$$</code> but specifies alternative <var>typealt</var> in the 
    union specified by the <code>%union</code> declaration. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC47">Data 
    Types of Values in Actions</a>. 
    <dt><samp>`$&lt;<var>typealt</var>&gt;<var>n</var>'</samp> 
    <dd>Like <code>$<VAR>n</VAR></code> but specifies alternative 
    <var>typealt</var> in the union specified by the <code>%union</code> 
    declaration. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC47">Data 
    Types of Values in Actions</a>. 
    <dt><samp>`YYABORT;'</samp> 
    <dd>Return immediately from <code>yyparse</code>, indicating failure. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a>. 
    <dt><samp>`YYACCEPT;'</samp> 
    <dd>Return immediately from <code>yyparse</code>, indicating success. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a>. 
    <dt><samp>`YYBACKUP (<var>token</var>, <var>value</var>);'</samp> 
    <dd><a name=IDX136></a>Unshift a token. This macro is allowed only for rules 
    that reduce a single value, and only when there is no look-ahead token. It 
    installs a look-ahead token with token type <var>token</var> and semantic 
    value <var>value</var>; then it discards the value that was going to be 
    reduced by this rule. If the macro is used when it is not valid, such as 
    when there is a look-ahead token already, then it reports a syntax error 
    with a message <samp>`cannot back up'</samp> and performs ordinary error 
    recovery. In either case, the rest of the action is not executed. 
    <dt><samp>`YYEMPTY'</samp> 
    <dd><a name=IDX137></a>Value stored in <code>yychar</code> when there is no 
    look-ahead token. 
    <dt><samp>`YYERROR;'</samp> 
    <dd><a name=IDX138></a>Cause an immediate syntax error. This statement 
    initiates error recovery just as if the parser itself had detected an error; 
    however, it does not call <code>yyerror</code>, and does not print any 
    message. If you want to print an error message, call <code>yyerror</code> 
    explicitly before the <samp>`YYERROR;'</samp> statement. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><samp>`YYRECOVERING'</samp> 
    <dd>This macro stands for an expression that has the value 1 when the parser 
    is recovering from a syntax error, and 0 the rest of the time. See section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><samp>`yychar'</samp> 
    <dd>Variable containing the current look-ahead token. (In a pure parser, 
    this is actually a local variable within <code>yyparse</code>.) When there 
    is no look-ahead token, the value <code>YYEMPTY</code> is stored in the 
    variable. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC69">Look-Ahead 
    Tokens</a>. 
    <dt><samp>`yyclearin;'</samp> 
    <dd>Discard the current look-ahead token. This is useful primarily in error 
    rules. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><samp>`yyerrok;'</samp> 
    <dd>Resume generating error messages immediately for subsequent syntax 
    errors. This is useful primarily in error rules. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><samp>`@<var>n</var>'</samp> 
    <dd><a name=IDX139></a>Acts like a structure variable containing information 
    on the line numbers and column numbers of the <var>n</var>th component of 
    the current rule. The structure has four members, like this: <pre>struct {
  int first_line, last_line;
  int first_column, last_column;
};
</pre>Thus, to get the starting line number of the third component, use 
    <samp>`@3.first_line'</samp>. In order for the members of this structure to 
    contain valid information, you must make <code>yylex</code> supply this 
    information about each token. If you need only certain members, then 
    <code>yylex</code> need only fill in those members. The use of this feature 
    makes the parser noticeably slower. </dd></dl>
  <p>
  <h1><a name=SEC68 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC68">The Bison 
  Parser Algorithm</a></h1>
  <p><a name=IDX140></a><a name=IDX141></a><a name=IDX142></a><a 
  name=IDX143></a><a name=IDX144></a><a name=IDX145></a>As Bison reads tokens, 
  it pushes them onto a stack along with their semantic values. The stack is 
  called the <em>parser stack</em>. Pushing a token is traditionally called 
  <em>shifting</em>. For example, suppose the infix calculator has read <samp>`1 
  + 5 *'</samp>, with a <samp>`3'</samp> to come. The stack will have four 
  elements, one for each token that was shifted. But the stack does not always 
  have an element for each token read. When the last <var>n</var> tokens and 
  groupings shifted match the components of a grammar rule, they can be combined 
  according to that rule. This is called <em>reduction</em>. Those tokens and 
  groupings are replaced on the stack by a single grouping whose symbol is the 
  result (left hand side) of that rule. Running the rule's action is part of the 
  process of reduction, because this is what computes the semantic value of the 
  resulting grouping. For example, if the infix calculator's parser stack 
  contains this: <pre>1 + 5 * 3
</pre>
  <p>and the next input token is a newline character, then the last three 
  elements can be reduced to 15 via the rule: <pre>expr: expr '*' expr;
</pre>
  <p>Then the stack contains just these three elements: <pre>1 + 15
</pre>
  <p>At this point, another reduction can be made, resulting in the single value 
  16. Then the newline token can be shifted. The parser tries, by shifts and 
  reductions, to reduce the entire input down to a single grouping whose symbol 
  is the grammar's start-symbol (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
  and Context-Free Grammars</a>). This kind of parser is known in the literature 
  as a bottom-up parser. 
  <h2><a name=SEC69 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC69">Look-Ahead 
  Tokens</a></h2>
  <p><a name=IDX146></a>The Bison parser does <em>not</em> always reduce 
  immediately as soon as the last <var>n</var> tokens and groupings match a 
  rule. This is because such a simple strategy is inadequate to handle most 
  languages. Instead, when a reduction is possible, the parser sometimes "looks 
  ahead" at the next token in order to decide what to do. When a token is read, 
  it is not immediately shifted; first it becomes the <em>look-ahead token</em>, 
  which is not on the stack. Now the parser can perform one or more reductions 
  of tokens and groupings on the stack, while the look-ahead token remains off 
  to the side. When no more reductions should take place, the look-ahead token 
  is shifted onto the stack. This does not mean that all possible reductions 
  have been done; depending on the token type of the look-ahead token, some 
  rules may choose to delay their application. Here is a simple case where 
  look-ahead is needed. These three rules define expressions which contain 
  binary addition operators and postfix unary factorial operators 
  (<samp>`!'</samp>), and allow parentheses for grouping. <pre>expr:     term '+' expr
        | term
        ;
term:     '(' expr ')'
        | term '!'
        | NUMBER
        ;
</pre>
  <p>Suppose that the tokens <samp>`1 + 2'</samp> have been read and shifted; 
  what should be done? If the following token is <samp>`)'</samp>, then the 
  first three tokens must be reduced to form an <code>expr</code>. This is the 
  only valid course, because shifting the <samp>`)'</samp> would produce a 
  sequence of symbols <code>term ')'</code>, and no rule allows this. If the 
  following token is <samp>`!'</samp>, then it must be shifted immediately so 
  that <samp>`2 !'</samp> can be reduced to make a <code>term</code>. If instead 
  the parser were to reduce before shifting, <samp>`1 + 2'</samp> would become 
  an <code>expr</code>. It would then be impossible to shift the 
  <samp>`!'</samp> because doing so would produce on the stack the sequence of 
  symbols <code>expr '!'</code>. No rule allows that sequence. <a 
  name=IDX147></a>The current look-ahead token is stored in the variable 
  <code>yychar</code>. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
  Features for Use in Actions</a>. 
  <h2><a name=SEC70 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC70">Shift/Reduce 
  Conflicts</a></h2>
  <p><a name=IDX148></a><a name=IDX149></a><a name=IDX150></a><a 
  name=IDX151></a>Suppose we are parsing a language which has if-then and 
  if-then-else statements, with a pair of rules like this: <pre>if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;
</pre>
  <p>Here we assume that <code>IF</code>, <code>THEN</code> and 
  <code>ELSE</code> are terminal symbols for specific keyword tokens. When the 
  <code>ELSE</code> token is read and becomes the look-ahead token, the contents 
  of the stack (assuming the input is valid) are just right for reduction by the 
  first rule. But it is also legitimate to shift the <code>ELSE</code>, because 
  that would lead to eventual reduction by the second rule. This situation, 
  where either a shift or a reduction would be valid, is called a 
  <em>shift/reduce conflict</em>. Bison is designed to resolve these conflicts 
  by choosing to shift, unless otherwise directed by operator precedence 
  declarations. To see the reason for this, let's contrast it with the other 
  alternative. Since the parser prefers to shift the <code>ELSE</code>, the 
  result is to attach the else-clause to the innermost if-statement, making 
  these two inputs equivalent: <pre>if x then if y then win (); else lose;
if x then do; if y then win (); else lose; end;
</pre>
  <p>But if the parser chose to reduce when possible rather than shift, the 
  result would be to attach the else-clause to the outermost if-statement, 
  making these two inputs equivalent: <pre>if x then if y then win (); else lose;
if x then do; if y then win (); end; else lose;
</pre>
  <p>The conflict exists because the grammar as written is ambiguous: either 
  parsing of the simple nested if-statement is legitimate. The established 
  convention is that these ambiguities are resolved by attaching the else-clause 
  to the innermost if-statement; this is what Bison accomplishes by choosing to 
  shift rather than reduce. (It would ideally be cleaner to write an unambiguous 
  grammar, but that is very hard to do in this case.) This particular ambiguity 
  was first encountered in the specifications of Algol 60 and is called the 
  "dangling <code>else</code>" ambiguity. To avoid warnings from Bison about 
  predictable, legitimate shift/reduce conflicts, use the <code>%expect 
  <VAR>n</VAR></code> declaration. There will be no warning as long as the 
  number of shift/reduce conflicts is exactly <var>n</var>. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC54">Suppressing 
  Conflict Warnings</a>. The definition of <code>if_stmt</code> above is solely 
  to blame for the conflict, but the conflict does not actually appear without 
  additional rules. Here is a complete Bison input file that actually manifests 
  the conflict: <pre>%token IF THEN ELSE variable
%%
stmt:     expr
        | if_stmt
        ;
if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;
expr:     variable
        ;
</pre>
  <p>
  <h2><a name=SEC71 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC71">Operator 
  Precedence</a></h2>
  <p><a name=IDX152></a><a name=IDX153></a>Another situation where shift/reduce 
  conflicts appear is in arithmetic expressions. Here shifting is not always the 
  preferred resolution; the Bison declarations for operator precedence allow you 
  to specify when to shift and when to reduce. 
  <h3><a name=SEC72 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC72">When 
  Precedence is Needed</a></h3>
  <p>Consider the following ambiguous grammar fragment (ambiguous because the 
  input <samp>`1 - 2 * 3'</samp> can be parsed in two different ways): <pre>expr:     expr '-' expr
        | expr '*' expr
        | expr '&lt;' expr
        | '(' expr ')'
        ...
        ;
</pre>
  <p>Suppose the parser has seen the tokens <samp>`1'</samp>, <samp>`-'</samp> 
  and <samp>`2'</samp>; should it reduce them via the rule for the addition 
  operator? It depends on the next token. Of course, if the next token is 
  <samp>`)'</samp>, we must reduce; shifting is invalid because no single rule 
  can reduce the token sequence <samp>`- 2 )'</samp> or anything starting with 
  that. But if the next token is <samp>`*'</samp> or <samp>`&lt;'</samp>, we 
  have a choice: either shifting or reduction would allow the parse to complete, 
  but with different results. To decide which one Bison should do, we must 
  consider the results. If the next operator token <var>op</var> is shifted, 
  then it must be reduced first in order to permit another opportunity to reduce 
  the sum. The result is (in effect) <samp>`1 - (2 <var>op</var> 3)'</samp>. On 
  the other hand, if the subtraction is reduced before shifting <var>op</var>, 
  the result is <samp>`(1 - 2) <var>op</var> 3'</samp>. Clearly, then, the 
  choice of shift or reduce should depend on the relative precedence of the 
  operators <samp>`-'</samp> and <var>op</var>: <samp>`*'</samp> should be 
  shifted first, but not <samp>`&lt;'</samp>. <a name=IDX154></a>What about 
  input such as <samp>`1 - 2 - 5'</samp>; should this be <samp>`(1 - 2) - 
  5'</samp> or should it be <samp>`1 - (2 - 5)'</samp>? For most operators we 
  prefer the former, which is called <em>left association</em>. The latter 
  alternative, <em>right association</em>, is desirable for assignment 
  operators. The choice of left or right association is a matter of whether the 
  parser chooses to shift or reduce when the stack contains <samp>`1 - 2'</samp> 
  and the look-ahead token is <samp>`-'</samp>: shifting makes 
  right-associativity. 
  <h3><a name=SEC73 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC73">Specifying 
  Operator Precedence</a></h3>
  <p><a name=IDX155></a><a name=IDX156></a><a name=IDX157></a>Bison allows you 
  to specify these choices with the operator precedence declarations 
  <code>%left</code> and <code>%right</code>. Each such declaration contains a 
  list of tokens, which are operators whose precedence and associativity is 
  being declared. The <code>%left</code> declaration makes all those operators 
  left-associative and the <code>%right</code> declaration makes them 
  right-associative. A third alternative is <code>%nonassoc</code>, which 
  declares that it is a syntax error to find the same operator twice "in a row". 
  The relative precedence of different operators is controlled by the order in 
  which they are declared. The first <code>%left</code> or <code>%right</code> 
  declaration in the file declares the operators whose precedence is lowest, the 
  next such declaration declares the operators whose precedence is a little 
  higher, and so on. 
  <h3><a name=SEC74 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC74">Precedence 
  Examples</a></h3>
  <p>In our example, we would want the following declarations: <pre>%left '&lt;'
%left '-'
%left '*'
</pre>
  <p>In a more complete example, which supports other operators as well, we 
  would declare them in groups of equal precedence. For example, 
  <code>'+'</code> is declared with <code>'-'</code>: <pre>%left '&lt;' '&gt;' '=' NE LE GE
%left '+' '-'
%left '*' '/'
</pre>
  <p>(Here <code>NE</code> and so on stand for the operators for "not equal" and 
  so on. We assume that these tokens are more than one character long and 
  therefore are represented by names, not character literals.) 
  <h3><a name=SEC75 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC75">How 
  Precedence Works</a></h3>
  <p>The first effect of the precedence declarations is to assign precedence 
  levels to the terminal symbols declared. The second effect is to assign 
  precedence levels to certain rules: each rule gets its precedence from the 
  last terminal symbol mentioned in the components. (You can also specify 
  explicitly the precedence of a rule. See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC76">Context-Dependent 
  Precedence</a>.) Finally, the resolution of conflicts works by comparing the 
  precedence of the rule being considered with that of the look-ahead token. If 
  the token's precedence is higher, the choice is to shift. If the rule's 
  precedence is higher, the choice is to reduce. If they have equal precedence, 
  the choice is made based on the associativity of that precedence level. The 
  verbose output file made by <samp>`-v'</samp> (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>) says how each conflict was resolved. Not all rules and not all 
  tokens have precedence. If either the rule or the look-ahead token has no 
  precedence, then the default is to shift. 
  <h2><a name=SEC76 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC76">Context-Dependent 
  Precedence</a></h2>
  <p><a name=IDX158></a><a name=IDX159></a><a name=IDX160></a><a 
  name=IDX161></a><a name=IDX162></a>Often the precedence of an operator depends 
  on the context. This sounds outlandish at first, but it is really very common. 
  For example, a minus sign typically has a very high precedence as a unary 
  operator, and a somewhat lower precedence (lower than multiplication) as a 
  binary operator. The Bison precedence declarations, <code>%left</code>, 
  <code>%right</code> and <code>%nonassoc</code>, can only be used once for a 
  given token; so a token has only one precedence declared in this way. For 
  context-dependent precedence, you need to use an additional mechanism: the 
  <code>%prec</code> modifier for rules. The <code>%prec</code> modifier 
  declares the precedence of a particular rule by specifying a terminal symbol 
  whose precedence should be used for that rule. It's not necessary for that 
  symbol to appear otherwise in the rule. The modifier's syntax is: <pre>%prec <var>terminal-symbol</var>
</pre>
  <p>and it is written after the components of the rule. Its effect is to assign 
  the rule the precedence of <var>terminal-symbol</var>, overriding the 
  precedence that would be deduced for it in the ordinary way. The altered rule 
  precedence then affects how conflicts involving that rule are resolved (see 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
  Precedence</a>). Here is how <code>%prec</code> solves the problem of unary 
  minus. First, declare a precedence for a fictitious terminal symbol named 
  <code>UMINUS</code>. There are no tokens of this type, but the symbol serves 
  to stand for its precedence: <pre>...
%left '+' '-'
%left '*'
%left UMINUS
</pre>
  <p>Now the precedence of <code>UMINUS</code> can be used in specific rules: <pre>exp:    ...
        | exp '-' exp
        ...
        | '-' exp %prec UMINUS
</pre>
  <p>
  <h2><a name=SEC77 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC77">Parser 
  States</a></h2>
  <p><a name=IDX163></a><a name=IDX164></a><a name=IDX165></a>The function 
  <code>yyparse</code> is implemented using a finite-state machine. The values 
  pushed on the parser stack are not simply token type codes; they represent the 
  entire sequence of terminal and nonterminal symbols at or near the top of the 
  stack. The current state collects all the information about previous input 
  which is relevant to deciding what to do next. Each time a look-ahead token is 
  read, the current parser state together with the type of look-ahead token are 
  looked up in a table. This table entry can say, "Shift the look-ahead token." 
  In this case, it also specifies the new parser state, which is pushed onto the 
  top of the parser stack. Or it can say, "Reduce using rule number 
  <var>n</var>." This means that a certain number of tokens or groupings are 
  taken off the top of the stack, and replaced by one grouping. In other words, 
  that number of states are popped from the stack, and one new state is pushed. 
  There is one other alternative: the table can say that the look-ahead token is 
  erroneous in the current state. This causes error processing to begin (see 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>). 
  <h2><a name=SEC78 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC78">Reduce/Reduce 
  Conflicts</a></h2>
  <p><a name=IDX166></a><a name=IDX167></a>A reduce/reduce conflict occurs if 
  there are two or more rules that apply to the same sequence of input. This 
  usually indicates a serious error in the grammar. For example, here is an 
  erroneous attempt to define a sequence of zero or more <code>word</code> 
  groupings. <pre>sequence: /* empty */
                { printf ("empty sequence\n"); }
        | maybeword
        | sequence word
                { printf ("added word %s\n", $2); }
        ;
maybeword: /* empty */
                { printf ("empty maybeword\n"); }
        | word
                { printf ("single word %s\n", $1); }
        ;
</pre>
  <p>The error is an ambiguity: there is more than one way to parse a single 
  <code>word</code> into a <code>sequence</code>. It could be reduced to a 
  <code>maybeword</code> and then into a <code>sequence</code> via the second 
  rule. Alternatively, nothing-at-all could be reduced into a 
  <code>sequence</code> via the first rule, and this could be combined with the 
  <code>word</code> using the third rule for <code>sequence</code>. There is 
  also more than one way to reduce nothing-at-all into a <code>sequence</code>. 
  This can be done directly via the first rule, or indirectly via 
  <code>maybeword</code> and then the second rule. You might think that this is 
  a distinction without a difference, because it does not change whether any 
  particular input is valid or not. But it does affect which actions are run. 
  One parsing order runs the second rule's action; the other runs the first 
  rule's action and the third rule's action. In this example, the output of the 
  program changes. Bison resolves a reduce/reduce conflict by choosing to use 
  the rule that appears first in the grammar, but it is very risky to rely on 
  this. Every reduce/reduce conflict must be studied and usually eliminated. 
  Here is the proper way to define <code>sequence</code>: <pre>sequence: /* empty */
                { printf ("empty sequence\n"); }
        | sequence word
                { printf ("added word %s\n", $2); }
        ;
</pre>
  <p>Here is another common error that yields a reduce/reduce conflict: <pre>sequence: /* empty */
        | sequence words
        | sequence redirects
        ;
words:    /* empty */
        | words word
        ;
redirects:/* empty */
        | redirects redirect
        ;
</pre>
  <p>The intention here is to define a sequence which can contain either 
  <code>word</code> or <code>redirect</code> groupings. The individual 
  definitions of <code>sequence</code>, <code>words</code> and 
  <code>redirects</code> are error-free, but the three together make a subtle 
  ambiguity: even an empty input can be parsed in infinitely many ways! 
  Consider: nothing-at-all could be a <code>words</code>. Or it could be two 
  <code>words</code> in a row, or three, or any number. It could equally well be 
  a <code>redirects</code>, or two, or any number. Or it could be a 
  <code>words</code> followed by three <code>redirects</code> and another 
  <code>words</code>. And so on. Here are two ways to correct these rules. 
  First, to make it a single level of sequence: <pre>sequence: /* empty */
        | sequence word
        | sequence redirect
        ;
</pre>
  <p>Second, to prevent either a <code>words</code> or a <code>redirects</code> 
  from being empty: <pre>sequence: /* empty */
        | sequence words
        | sequence redirects
        ;
words:    word
        | words word
        ;
redirects:redirect
        | redirects redirect
        ;
</pre>
  <p>
  <h2><a name=SEC79 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC79">Mysterious 
  Reduce/Reduce Conflicts</a></h2>
  <p>Sometimes reduce/reduce conflicts can occur that don't look warranted. Here 
  is an example: <pre>%token ID
%%
def:    param_spec return_spec ','
        ;
param_spec:
             type
        |    name_list ':' type
        ;
return_spec:
             type
        |    name ':' type
        ;
type:        ID
        ;
name:        ID
        ;
name_list:
             name
        |    name ',' name_list
        ;
</pre>
  <p>It would seem that this grammar can be parsed with only a single token of 
  look-ahead: when a <code>param_spec</code> is being read, an <code>ID</code> 
  is a <code>name</code> if a comma or colon follows, or a <code>type</code> if 
  another <code>ID</code> follows. In other words, this grammar is LR(1). <a 
  name=IDX168></a><a name=IDX169></a>However, Bison, like most parser 
  generators, cannot actually handle all LR(1) grammars. In this grammar, two 
  contexts, that after an <code>ID</code> at the beginning of a 
  <code>param_spec</code> and likewise at the beginning of a 
  <code>return_spec</code>, are similar enough that Bison assumes they are the 
  same. They appear similar because the same set of rules would be active--the 
  rule for reducing to a <code>name</code> and that for reducing to a 
  <code>type</code>. Bison is unable to determine at that stage of processing 
  that the rules would require different look-ahead tokens in the two contexts, 
  so it makes a single parser state for them both. Combining the two contexts 
  causes a conflict later. In parser terminology, this occurrence means that the 
  grammar is not LALR(1). In general, it is better to fix deficiencies than to 
  document them. But this particular deficiency is intrinsically hard to fix; 
  parser generators that can handle LR(1) grammars are hard to write and tend to 
  produce parsers that are very large. In practice, Bison is more useful as it 
  is now. When the problem arises, you can often fix it by identifying the two 
  parser states that are being confused, and adding something to make them look 
  distinct. In the above example, adding one rule to <code>return_spec</code> as 
  follows makes the problem go away: <pre>%token BOGUS
...
%%
...
return_spec:
             type
        |    name ':' type
        /* This rule is never used.  */
        |    ID BOGUS
        ;
</pre>
  <p>This corrects the problem because it introduces the possibility of an 
  additional active rule in the context after the <code>ID</code> at the 
  beginning of <code>return_spec</code>. This rule is not active in the 
  corresponding context in a <code>param_spec</code>, so the two contexts 
  receive distinct parser states. As long as the token <code>BOGUS</code> is 
  never generated by <code>yylex</code>, the added rule cannot alter the way 
  actual input is parsed. In this particular example, there is another way to 
  solve the problem: rewrite the rule for <code>return_spec</code> to use 
  <code>ID</code> directly instead of via <code>name</code>. This also causes 
  the two confusing contexts to have different sets of active rules, because the 
  one for <code>return_spec</code> activates the altered rule for 
  <code>return_spec</code> rather than the one for <code>name</code>. <pre>param_spec:
             type
        |    name_list ':' type
        ;
return_spec:
             type
        |    ID ':' type
        ;
</pre>
  <p>
  <h2><a name=SEC80 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC80">Stack 
  Overflow, and How to Avoid It</a></h2>
  <p><a name=IDX170></a><a name=IDX171></a><a name=IDX172></a>The Bison parser 
  stack can overflow if too many tokens are shifted and not reduced. When this 
  happens, the parser function <code>yyparse</code> returns a nonzero value, 
  pausing only to call <code>yyerror</code> to report the overflow. <a 
  name=IDX173></a>By defining the macro <code>YYMAXDEPTH</code>, you can control 
  how deep the parser stack can become before a stack overflow occurs. Define 
  the macro with a value that is an integer. This value is the maximum number of 
  tokens that can be shifted (and not reduced) before overflow. It must be a 
  constant expression whose value is known at compile time. The stack space 
  allowed is not necessarily allocated. If you specify a large value for 
  <code>YYMAXDEPTH</code>, the parser actually allocates a small stack at first, 
  and then makes it bigger by stages as needed. This increasing allocation 
  happens automatically and silently. Therefore, you do not need to make 
  <code>YYMAXDEPTH</code> painfully small merely to save space for ordinary 
  inputs that do not need much stack. <a name=IDX174></a>The default value of 
  <code>YYMAXDEPTH</code>, if you do not define it, is 10000. <a 
  name=IDX175></a>You can control how much stack is allocated initially by 
  defining the macro <code>YYINITDEPTH</code>. This value too must be a 
  compile-time constant integer. The default is 200. 
  <h1><a name=SEC81 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC81">Error 
  Recovery</a></h1>
  <p><a name=IDX176></a><a name=IDX177></a>It is not usually acceptable to have 
  a program terminate on a parse error. For example, a compiler should recover 
  sufficiently to parse the rest of the input file and check it for errors; a 
  calculator should accept another expression. In a simple interactive command 
  parser where each input is one line, it may be sufficient to allow 
  <code>yyparse</code> to return 1 on error and have the caller ignore the rest 
  of the input line when that happens (and then call <code>yyparse</code> 
  again). But this is inadequate for a compiler, because it forgets all the 
  syntactic context leading up to the error. A syntax error deep within a 
  function in the compiler input should not cause the compiler to treat the 
  following line like the beginning of a source file. <a name=IDX178></a>You can 
  define how to recover from a syntax error by writing rules to recognize the 
  special token <code>error</code>. This is a terminal symbol that is always 
  defined (you need not declare it) and reserved for error handling. The Bison 
  parser generates an <code>error</code> token whenever a syntax error happens; 
  if you have provided a rule to recognize this token in the current context, 
  the parse can continue. For example: <pre>stmnts:  /* empty string */
        | stmnts '\n'
        | stmnts exp '\n'
        | stmnts error '\n'
</pre>
  <p>The fourth rule in this example says that an error followed by a newline 
  makes a valid addition to any <code>stmnts</code>. What happens if a syntax 
  error occurs in the middle of an <code>exp</code>? The error recovery rule, 
  interpreted strictly, applies to the precise sequence of a 
  <code>stmnts</code>, an <code>error</code> and a newline. If an error occurs 
  in the middle of an <code>exp</code>, there will probably be some additional 
  tokens and subexpressions on the stack after the last <code>stmnts</code>, and 
  there will be tokens to read before the next newline. So the rule is not 
  applicable in the ordinary way. But Bison can force the situation to fit the 
  rule, by discarding part of the semantic context and part of the input. First 
  it discards states and objects from the stack until it gets back to a state in 
  which the <code>error</code> token is acceptable. (This means that the 
  subexpressions already parsed are discarded, back to the last complete 
  <code>stmnts</code>.) At this point the <code>error</code> token can be 
  shifted. Then, if the old look-ahead token is not acceptable to be shifted 
  next, the parser reads tokens and discards them until it finds a token which 
  is acceptable. In this example, Bison reads and discards input until the next 
  newline so that the fourth rule can apply. The choice of error rules in the 
  grammar is a choice of strategies for error recovery. A simple and useful 
  strategy is simply to skip the rest of the current input line or current 
  statement if an error is detected: <pre>stmnt: error ';'  /* on error, skip until ';' is read */
</pre>
  <p>It is also useful to recover to the matching close-delimiter of an 
  opening-delimiter that has already been parsed. Otherwise the close-delimiter 
  will probably appear to be unmatched, and generate another, spurious error 
  message: <pre>primary:  '(' expr ')'
        | '(' error ')'
        ...
        ;
</pre>
  <p>Error recovery strategies are necessarily guesses. When they guess wrong, 
  one syntax error often leads to another. In the above example, the error 
  recovery rule guesses that an error is due to bad input within one 
  <code>stmnt</code>. Suppose that instead a spurious semicolon is inserted in 
  the middle of a valid <code>stmnt</code>. After the error recovery rule 
  recovers from the first error, another syntax error will be found 
  straightaway, since the text following the spurious semicolon is also an 
  invalid <code>stmnt</code>. To prevent an outpouring of error messages, the 
  parser will output no error message for another syntax error that happens 
  shortly after the first; only after three consecutive input tokens have been 
  successfully shifted will error messages resume. Note that rules which accept 
  the <code>error</code> token may have actions, just as any other rules can. <a 
  name=IDX179></a>You can make error messages resume immediately by using the 
  macro <code>yyerrok</code> in an action. If you do this in the error rule's 
  action, no error messages will be suppressed. This macro requires no 
  arguments; <samp>`yyerrok;'</samp> is a valid C statement. <a 
  name=IDX180></a>The previous look-ahead token is reanalyzed immediately after 
  an error. If this is unacceptable, then the macro <code>yyclearin</code> may 
  be used to clear this token. Write the statement <samp>`yyclearin;'</samp> in 
  the error rule's action. For example, suppose that on a parse error, an error 
  handling routine is called that advances the input stream to some point where 
  parsing should once again commence. The next symbol returned by the lexical 
  scanner is probably correct. The previous look-ahead token ought to be 
  discarded with <samp>`yyclearin;'</samp>. <a name=IDX181></a>The macro 
  <code>YYRECOVERING</code> stands for an expression that has the value 1 when 
  the parser is recovering from a syntax error, and 0 the rest of the time. A 
  value of 1 indicates that error messages are currently suppressed for new 
  syntax errors. 
  <h1><a name=SEC82 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC82">Handling 
  Context Dependencies</a></h1>
  <p>The Bison paradigm is to parse tokens first, then group them into larger 
  syntactic units. In many languages, the meaning of a token is affected by its 
  context. Although this violates the Bison paradigm, certain techniques (known 
  as <em>kludges</em>) may enable you to write Bison parsers for such languages. 
  (Actually, "kludge" means any technique that gets its job done but is neither 
  clean nor robust.) 
  <h2><a name=SEC83 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC83">Semantic 
  Info in Token Types</a></h2>
  <p>The C language has a context dependency: the way an identifier is used 
  depends on what its current meaning is. For example, consider this: <pre>foo (x);
</pre>
  <p>This looks like a function call statement, but if <code>foo</code> is a 
  typedef name, then this is actually a declaration of <code>x</code>. How can a 
  Bison parser for C decide how to parse this input? The method used in GNU C is 
  to have two different token types, <code>IDENTIFIER</code> and 
  <code>TYPENAME</code>. When <code>yylex</code> finds an identifier, it looks 
  up the current declaration of the identifier in order to decide which token 
  type to return: <code>TYPENAME</code> if the identifier is declared as a 
  typedef, <code>IDENTIFIER</code> otherwise. The grammar rules can then express 
  the context dependency by the choice of token type to recognize. 
  <code>IDENTIFIER</code> is accepted as an expression, but 
  <code>TYPENAME</code> is not. <code>TYPENAME</code> can start a declaration, 
  but <code>IDENTIFIER</code> cannot. In contexts where the meaning of the 
  identifier is <em>not</em> significant, such as in declarations that can 
  shadow a typedef name, either <code>TYPENAME</code> or <code>IDENTIFIER</code> 
  is accepted--there is one rule for each of the two token types. This technique 
  is simple to use if the decision of which kinds of identifiers to allow is 
  made at a place close to where the identifier is parsed. But in C this is not 
  always so: C allows a declaration to redeclare a typedef name provided an 
  explicit type has been specified earlier: <pre>typedef int foo, bar, lose;
static foo (bar);        /* redeclare <code>bar</code> as static variable */
static int foo (lose);   /* redeclare <code>foo</code> as function */
</pre>
  <p>Unfortunately, the name being declared is separated from the declaration 
  construct itself by a complicated syntactic structure--the "declarator". As a 
  result, the part of Bison parser for C needs to be duplicated, with all the 
  nonterminal names changed: once for parsing a declaration in which a typedef 
  name can be redefined, and once for parsing a declaration in which that can't 
  be done. Here is a part of the duplication, with actions omitted for brevity: <pre>initdcl:
          declarator maybeasm '='
          init
        | declarator maybeasm
        ;
notype_initdcl:
          notype_declarator maybeasm '='
          init
        | notype_declarator maybeasm
        ;
</pre>
  <p>Here <code>initdcl</code> can redeclare a typedef name, but 
  <code>notype_initdcl</code> cannot. The distinction between 
  <code>declarator</code> and <code>notype_declarator</code> is the same sort of 
  thing. There is some similarity between this technique and a lexical tie-in 
  (described next), in that information which alters the lexical analysis is 
  changed during parsing by other parts of the program. The difference is here 
  the information is global, and is used for other purposes in the program. A 
  true lexical tie-in has a special-purpose flag controlled by the syntactic 
  context. 
  <h2><a name=SEC84 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC84">Lexical 
  Tie-ins</a></h2>
  <p><a name=IDX182></a>One way to handle context-dependency is the <em>lexical 
  tie-in</em>: a flag which is set by Bison actions, whose purpose is to alter 
  the way tokens are parsed. For example, suppose we have a language vaguely 
  like C, but with a special construct <samp>`hex (<var>hex-expr</var>)'</samp>. 
  After the keyword <code>hex</code> comes an expression in parentheses in which 
  all integers are hexadecimal. In particular, the token <samp>`a1b'</samp> must 
  be treated as an integer rather than as an identifier if it appears in that 
  context. Here is how you can do it: <pre>%{
int hexflag;
%}
%%
...
expr:   IDENTIFIER
        | constant
        | HEX '('
                { hexflag = 1; }
          expr ')'
                { hexflag = 0;
                   $$ = $4; }
        | expr '+' expr
                { $$ = make_sum ($1, $3); }
        ...
        ;
constant:
          INTEGER
        | STRING
        ;
</pre>
  <p>Here we assume that <code>yylex</code> looks at the value of 
  <code>hexflag</code>; when it is nonzero, all integers are parsed in 
  hexadecimal, and tokens starting with letters are parsed as integers if 
  possible. The declaration of <code>hexflag</code> shown in the C declarations 
  section of the parser file is needed to make it accessible to the actions (see 
  section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC36">The C 
  Declarations Section</a>). You must also write the code in <code>yylex</code> 
  to obey the flag. 
  <h2><a name=SEC85 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC85">Lexical 
  Tie-ins and Error Recovery</a></h2>
  <p>Lexical tie-ins make strict demands on any error recovery rules you have. 
  See section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
  Recovery</a>. The reason for this is that the purpose of an error recovery 
  rule is to abort the parsing of one construct and resume in some larger 
  construct. For example, in C-like languages, a typical error recovery rule is 
  to skip tokens until the next semicolon, and then start a new statement, like 
  this: <pre>stmt:   expr ';'
        | IF '(' expr ')' stmt { ... }
        ...
        error ';'
                { hexflag = 0; }
        ;
</pre>
  <p>If there is a syntax error in the middle of a <samp>`hex 
  (<var>expr</var>)'</samp> construct, this error rule will apply, and then the 
  action for the completed <samp>`hex (<var>expr</var>)'</samp> will never run. 
  So <code>hexflag</code> would remain set for the entire rest of the input, or 
  until the next <code>hex</code> keyword, causing identifiers to be 
  misinterpreted as integers. To avoid this problem the error recovery rule 
  itself clears <code>hexflag</code>. There may also be an error recovery rule 
  that works within expressions. For example, there could be a rule which 
  applies within parentheses and skips to the close-parenthesis: <pre>expr:   ...
        | '(' expr ')'
                { $$ = $2; }
        | '(' error ')'
        ...
</pre>
  <p>If this rule acts within the <code>hex</code> construct, it is not going to 
  abort that construct (since it applies to an inner level of parentheses within 
  the construct). Therefore, it should not clear the flag: the rest of the 
  <code>hex</code> construct should be parsed with the flag still in effect. 
  What if there is an error recovery rule which might abort out of the 
  <code>hex</code> construct or might not, depending on circumstances? There is 
  no way you can write the action to determine whether a <code>hex</code> 
  construct is being aborted or not. So if you are using a lexical tie-in, you 
  had better make sure your error recovery rules are not of this kind. Each rule 
  must be such that you can be sure that it always will, or always won't, have 
  to clear the flag. 
  <h1><a name=SEC86 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC86">Debugging 
  Your Parser</a></h1>
  <p><a name=IDX183></a><a name=IDX184></a><a name=IDX185></a><a 
  name=IDX186></a>If a Bison grammar compiles properly but doesn't do what you 
  want when it runs, the <code>yydebug</code> parser-trace feature can help you 
  figure out why. To enable compilation of trace facilities, you must define the 
  macro <code>YYDEBUG</code> when you compile the parser. You could use 
  <samp>`-DYYDEBUG=1'</samp> as a compiler option or you could put 
  <samp>`#define YYDEBUG 1'</samp> in the C declarations section of the grammar 
  file (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC36">The C 
  Declarations Section</a>). Alternatively, use the <samp>`-t'</samp> option 
  when you run Bison (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>). We always define <code>YYDEBUG</code> so that debugging is always 
  possible. The trace facility uses <code>stderr</code>, so you must add 
  <code>#include &lt;stdio.h&gt;</code> to the C declarations section unless it 
  is already there. Once you have compiled the program with trace facilities, 
  the way to request a trace is to store a nonzero value in the variable 
  <code>yydebug</code>. You can do this by making the C code do it (in 
  <code>main</code>, perhaps), or you can alter the value with a C debugger. 
  Each step taken by the parser when <code>yydebug</code> is nonzero produces a 
  line or two of trace information, written on <code>stderr</code>. The trace 
  messages tell you these things: 
  <ul>
    <li>Each time the parser calls <code>yylex</code>, what kind of token was 
    read. 
    <li>Each time a token is shifted, the depth and complete contents of the 
    state stack (see section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC77">Parser 
    States</a>). 
    <li>Each time a rule is reduced, which rule it is, and the complete contents 
    of the state stack afterward. </li></ul>
  <p>To make sense of this information, it helps to refer to the listing file 
  produced by the Bison <samp>`-v'</samp> option (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC87">Invoking 
  Bison</a>). This file shows the meaning of each state in terms of positions in 
  various rules, and also what each state will do with each possible input 
  token. As you read the successive trace messages, you can see that the parser 
  is functioning according to its specification in the listing file. Eventually 
  you will arrive at the place where something undesirable happens, and you will 
  see which parts of the grammar are to blame. The parser file is a C program 
  and you can use C debuggers on it, but it's not easy to interpret what it is 
  doing. The parser function is a finite-state machine interpreter, and aside 
  from the actions it executes the same code over and over. Only the values of 
  variables show where in the grammar it is working. <a name=IDX187></a>The 
  debugging information normally gives the token type of each token read, but 
  not its semantic value. You can optionally define a macro named 
  <code>YYPRINT</code> to provide a way to print the value. If you define 
  <code>YYPRINT</code>, it should take three arguments. The parser will pass a 
  standard I/O stream, the numeric code for the token type, and the token value 
  (from <code>yylval</code>). Here is an example of <code>YYPRINT</code> 
  suitable for the multi-function calculator (see section <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC30">Declarations 
  for <code>mfcalc</code></a>): <pre>#define YYPRINT(file, type, value)   yyprint (file, type, value)
static void
yyprint (file, type, value)
     FILE *file;
     int type;
     YYSTYPE value;
{
  if (type == VAR)
    fprintf (file, " %s", value.tptr-&gt;name);
  else if (type == NUM)
    fprintf (file, " %d", value.val);
}
</pre>
  <p>
  <h1><a name=SEC87 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC87">Invoking 
  Bison</a></h1>
  <p><a name=IDX188></a><a name=IDX189></a><a name=IDX190></a>The usual way to 
  invoke Bison is as follows: <pre>bison <var>infile</var>
</pre>
  <p>Here <var>infile</var> is the grammar file name, which usually ends in 
  <samp>`.y'</samp>. The parser file's name is made by replacing the 
  <samp>`.y'</samp> with <samp>`.tab.c'</samp>. Thus, the <samp>`bison 
  foo.y'</samp> filename yields <tt>`foo.tab.c'</tt>, and the <samp>`bison 
  hack/foo.y'</samp> filename yields <tt>`hack/foo.tab.c'</tt>. 
  <h2><a name=SEC88 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC88">Bison 
  Options</a></h2>
  <p>Bison supports both traditional single-letter options and mnemonic long 
  option names. Long option names are indicated with <samp>`--'</samp> instead 
  of <samp>`-'</samp>. Abbreviations for option names are allowed as long as 
  they are unique. When a long option takes an argument, like 
  <samp>`--file-prefix'</samp>, connect the option name and the argument with 
  <samp>`='</samp>. Here is a list of options that can be used with Bison, 
  alphabetized by short option. It is followed by a cross key alphabetized by 
  long option. 
  <dl compact>
    <dt><samp>`-b <var>file-prefix</var>'</samp> 
    <dd>
    <dt><samp>`--file-prefix=<var>prefix</var>'</samp> 
    <dd>Specify a prefix to use for all Bison output file names. The names are 
    chosen as if the input file were named <tt>`<var>prefix</var>.c'</tt>. 
    <dt><samp>`-d'</samp> 
    <dd>
    <dt><samp>`--defines'</samp> 
    <dd>Write an extra output file containing macro definitions for the token 
    type names defined in the grammar and the semantic value type 
    <code>YYSTYPE</code>, as well as a few <code>extern</code> variable 
    declarations. If the parser output file is named 
    <tt>`<var>name</var>.c'</tt> then this file is named 
    <tt>`<var>name</var>.h'</tt>. This output file is essential if you wish to 
    put the definition of <code>yylex</code> in a separate source file, because 
    <code>yylex</code> needs to be able to refer to token type codes and the 
    variable <code>yylval</code>. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC63">Semantic 
    Values of Tokens</a>. 
    <dt><samp>`-l'</samp> 
    <dd>
    <dt><samp>`--no-lines'</samp> 
    <dd>Don't put any <code>#line</code> preprocessor commands in the parser 
    file. Ordinarily Bison puts them in the parser file so that the C compiler 
    and debuggers will associate errors with your source file, the grammar file. 
    This option causes them to associate errors with the parser file, treating 
    it an independent source file in its own right. 
    <dt><samp>`-o <var>outfile</var>'</samp> 
    <dd>
    <dt><samp>`--output-file=<var>outfile</var>'</samp> 
    <dd>Specify the name <var>outfile</var> for the parser file. The other 
    output files' names are constructed from <var>outfile</var> as described 
    under the <samp>`-v'</samp> and <samp>`-d'</samp> switches. 
    <dt><samp>`-p <var>prefix</var>'</samp> 
    <dd>
    <dt><samp>`--name-prefix=<var>prefix</var>'</samp> 
    <dd>Rename the external symbols used in the parser so that they start with 
    <var>prefix</var> instead of <samp>`yy'</samp>. The precise list of symbols 
    renamed is <code>yyparse</code>, <code>yylex</code>, <code>yyerror</code>, 
    <code>yynerrs</code>, <code>yylval</code>, <code>yychar</code> and 
    <code>yydebug</code>. For example, if you use <samp>`-p c'</samp>, the names 
    become <code>cparse</code>, <code>clex</code>, and so on. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC58">Multiple 
    Parsers in the Same Program</a>. 
    <dt><samp>`-t'</samp> 
    <dd>
    <dt><samp>`--debug'</samp> 
    <dd>Output a definition of the macro <code>YYDEBUG</code> into the parser 
    file, so that the debugging facilities are compiled. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC86">Debugging 
    Your Parser</a>. 
    <dt><samp>`-v'</samp> 
    <dd>
    <dt><samp>`--verbose'</samp> 
    <dd>Write an extra output file containing verbose descriptions of the parser 
    states and what is done for each type of look-ahead token in that state. 
    This file also describes all the conflicts, both those resolved by operator 
    precedence and the unresolved ones. The file's name is made by removing 
    <samp>`.tab.c'</samp> or <samp>`.c'</samp> from the parser output file name, 
    and adding <samp>`.output'</samp> instead. Therefore, if the input file is 
    <tt>`foo.y'</tt>, then the parser file is called <tt>`foo.tab.c'</tt> by 
    default. As a consequence, the verbose output file is called 
    <tt>`foo.output'</tt>. 
    <dt><samp>`-V'</samp> 
    <dd>
    <dt><samp>`--version'</samp> 
    <dd>Print the version number of Bison and exit. 
    <dt><samp>`-h'</samp> 
    <dd>
    <dt><samp>`--help'</samp> 
    <dd>Print a summary of the command-line options to Bison and exit. 
    <dt><samp>`-y'</samp> 
    <dd>
    <dt><samp>`--yacc'</samp> 
    <dd>
    <dt><samp>`--fixed-output-files'</samp> 
    <dd>Equivalent to <samp>`-o y.tab.c'</samp>; the parser output file is 
    called <tt>`y.tab.c'</tt>, and the other outputs are called 
    <tt>`y.output'</tt> and <tt>`y.tab.h'</tt>. The purpose of this switch is to 
    imitate Yacc's output file name conventions. Thus, the following shell 
    script can substitute for Yacc: <pre>bison -y $*
</pre></dd></dl>
  <p>
  <h2><a name=SEC89 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC89">Option 
  Cross Key</a></h2>
  <p>Here is a list of options, alphabetized by long option, to help you find 
  the corresponding short option. 
  <h2><a name=SEC90 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC90">Invoking 
  Bison under VMS</a></h2>
  <p><a name=IDX191></a><a name=IDX192></a>The command line syntax for Bison on 
  VMS is a variant of the usual Bison command syntax--adapted to fit VMS 
  conventions. To find the VMS equivalent for any Bison option, start with the 
  long option, and substitute a <samp>`/'</samp> for the leading 
  <samp>`--'</samp>, and substitute a <samp>`_'</samp> for each <samp>`-'</samp> 
  in the name of the long option. For example, the following invocation under 
  VMS: <pre>bison /debug/name_prefix=bar foo.y
</pre>
  <p>is equivalent to the following command under POSIX. <pre>bison --debug --name-prefix=bar foo.y
</pre>
  <p>The VMS file system does not permit filenames such as <tt>`foo.tab.c'</tt>. 
  In the above example, the output file would instead be named 
  <tt>`foo_tab.c'</tt>. 
  <h1><a name=SEC91 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC91">Bison 
  Symbols</a></h1>
  <p><a name=IDX193></a><a name=IDX194></a>
  <dl compact>
    <dt><code>error</code> 
    <dd>A token name reserved for error recovery. This token may be used in 
    grammar rules so as to allow the Bison parser to recognize an error in the 
    grammar without halting the process. In effect, a sentence containing an 
    error may be recognized as valid. On a parse error, the token 
    <code>error</code> becomes the current look-ahead token. Actions 
    corresponding to <code>error</code> are then executed, and the look-ahead 
    token is reset to the token that originally caused the violation. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><code>YYABORT</code> 
    <dd>Macro to pretend that an unrecoverable syntax error has occurred, by 
    making <code>yyparse</code> return 1 immediately. The error reporting 
    function <code>yyerror</code> is not called. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a>. 
    <dt><code>YYACCEPT</code> 
    <dd>Macro to pretend that a complete utterance of the language has been 
    read, by making <code>yyparse</code> return 0 immediately. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a>. 
    <dt><code>YYBACKUP</code> 
    <dd>Macro to discard a value from the parser stack and fake a look-ahead 
    token. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
    Features for Use in Actions</a>. 
    <dt><code>YYERROR</code> 
    <dd>Macro to pretend that a syntax error has just been detected: call 
    <code>yyerror</code> and then perform normal error recovery if possible (see 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>), or (if recovery is impossible) make <code>yyparse</code> 
    return 1. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><code>YYERROR_VERBOSE</code> 
    <dd>Macro that you define with <code>#define</code> in the Bison 
    declarations section to request verbose, specific error message strings when 
    <code>yyerror</code> is called. 
    <dt><code>YYINITDEPTH</code> 
    <dd>Macro for specifying the initial size of the parser stack. See section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC80">Stack 
    Overflow, and How to Avoid It</a>. 
    <dt><code>YYLEX_PARAM</code> 
    <dd>Macro for specifying an extra argument (or list of extra arguments) for 
    <code>yyparse</code> to pass to <code>yylex</code>. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC65">Calling 
    Conventions for Pure Parsers</a>. 
    <dt><code>YYLTYPE</code> 
    <dd>Macro for the data type of <code>yylloc</code>; a structure with four 
    members. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC64">Textual 
    Positions of Tokens</a>. 
    <dt><code>YYMAXDEPTH</code> 
    <dd>Macro for specifying the maximum size of the parser stack. See section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC80">Stack 
    Overflow, and How to Avoid It</a>. 
    <dt><code>YYPARSE_PARAM</code> 
    <dd>Macro for specifying the name of a parameter that <code>yyparse</code> 
    should accept. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC65">Calling 
    Conventions for Pure Parsers</a>. 
    <dt><code>YYRECOVERING</code> 
    <dd>Macro whose value indicates whether the parser is recovering from a 
    syntax error. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
    Features for Use in Actions</a>. 
    <dt><code>YYSTYPE</code> 
    <dd>Macro for the data type of semantic values; <code>int</code> by default. 
    See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC44">Data 
    Types of Semantic Values</a>. 
    <dt><code>yychar</code> 
    <dd>External integer variable that contains the integer value of the current 
    look-ahead token. (In a pure parser, it is a local variable within 
    <code>yyparse</code>.) Error-recovery rule actions may examine this 
    variable. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC67">Special 
    Features for Use in Actions</a>. 
    <dt><code>yyclearin</code> 
    <dd>Macro used in error-recovery rule actions. It clears the previous 
    look-ahead token. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><code>yydebug</code> 
    <dd>External integer variable set to zero by default. If 
    <code>yydebug</code> is given a nonzero value, the parser will output 
    information on input symbols and parser action. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC86">Debugging 
    Your Parser</a>. 
    <dt><code>yyerrok</code> 
    <dd>Macro to cause parser to recover immediately to its normal mode after a 
    parse error. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt><code>yyerror</code> 
    <dd>User-supplied function to be called by <code>yyparse</code> on error. 
    The function receives one argument, a pointer to a character string 
    containing an error message. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC66">The Error 
    Reporting Function <code>yyerror</code></a>. 
    <dt><code>yylex</code> 
    <dd>User-supplied lexical analyzer function, called with no arguments to get 
    the next token. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The 
    Lexical Analyzer Function <code>yylex</code></a>. 
    <dt><code>yylval</code> 
    <dd>External variable in which <code>yylex</code> should place the semantic 
    value associated with a token. (In a pure parser, it is a local variable 
    within <code>yyparse</code>, and its address is passed to 
    <code>yylex</code>.) See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC63">Semantic 
    Values of Tokens</a>. 
    <dt><code>yylloc</code> 
    <dd>External variable in which <code>yylex</code> should place the line and 
    column numbers associated with a token. (In a pure parser, it is a local 
    variable within <code>yyparse</code>, and its address is passed to 
    <code>yylex</code>.) You can ignore this variable if you don't use the 
    <samp>`@'</samp> feature in the grammar actions. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC64">Textual 
    Positions of Tokens</a>. 
    <dt><code>yynerrs</code> 
    <dd>Global variable which Bison increments each time there is a parse error. 
    (In a pure parser, it is a local variable within <code>yyparse</code>.) See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC66">The Error 
    Reporting Function <code>yyerror</code></a>. 
    <dt><code>yyparse</code> 
    <dd>The parser function produced by Bison; call this function to start 
    parsing. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC60">The 
    Parser Function <code>yyparse</code></a>. 
    <dt><code>%left</code> 
    <dd>Bison declaration to assign left associativity to token(s). See section 
    <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>. 
    <dt><code>%nonassoc</code> 
    <dd>Bison declaration to assign nonassociativity to token(s). See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>. 
    <dt><code>%prec</code> 
    <dd>Bison declaration to assign a precedence to a specific rule. See section 
    <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC76">Context-Dependent 
    Precedence</a>. 
    <dt><code>%pure_parser</code> 
    <dd>Bison declaration to request a pure (reentrant) parser. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
    (Reentrant) Parser</a>. 
    <dt><code>%right</code> 
    <dd>Bison declaration to assign right associativity to token(s). See section 
    <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC51">Operator 
    Precedence</a>. 
    <dt><code>%start</code> 
    <dd>Bison declaration to specify the start symbol. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC55">The 
    Start-Symbol</a>. 
    <dt><code>%token</code> 
    <dd>Bison declaration to declare token(s) without specifying precedence. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC50">Token 
    Type Names</a>. 
    <dt><code>%type</code> 
    <dd>Bison declaration to declare nonterminals. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC53">Nonterminal 
    Symbols</a>. 
    <dt><code>%union</code> 
    <dd>Bison declaration to specify several possible data types for semantic 
    values. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC52">The 
    Collection of Value Types</a>. </dd></dl>
  <p>These are the punctuation and delimiters used in Bison input: 
  <dl compact>
    <dt><samp>`%%'</samp> 
    <dd>Delimiter used to separate the grammar rule section from the Bison 
    declarations section or the additional C code section. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC14">The 
    Overall Layout of a Bison Grammar</a>. 
    <dt><samp>`%{ %}'</samp> 
    <dd>All code listed between <samp>`%{'</samp> and <samp>`%}'</samp> is 
    copied directly to the output file uninterpreted. Such code forms the "C 
    declarations" section of the input file. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC35">Outline 
    of a Bison Grammar</a>. 
    <dt><samp>`/*...*/'</samp> 
    <dd>Comment delimiters, as in C. 
    <dt><samp>`:'</samp> 
    <dd>Separates a rule's result from its components. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax of 
    Grammar Rules</a>. 
    <dt><samp>`;'</samp> 
    <dd>Terminates a rule. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax of 
    Grammar Rules</a>. 
    <dt><samp>`|'</samp> 
    <dd>Separates alternate rules for the same result nonterminal. See section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC41">Syntax 
    of Grammar Rules</a>. </dd></dl>
  <p>
  <h1><a name=SEC92 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC92">Glossary</a></h1>
  <p><a name=IDX195></a>
  <dl compact>
    <dt>Backus-Naur Form (BNF) 
    <dd>Formal method of specifying context-free grammars. BNF was first used in 
    the <cite>ALGOL-60</cite> report, 1963. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a>. 
    <dt>Context-free grammars 
    <dd>Grammars specified as rules that can be applied regardless of context. 
    Thus, if there is a rule which says that an integer can be used as an 
    expression, integers are allowed <em>anywhere</em> an expression is 
    permitted. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a>. 
    <dt>Dynamic allocation 
    <dd>Allocation of memory that occurs during execution, rather than at 
    compile time or on entry to a function. 
    <dt>Empty string 
    <dd>Analogous to the empty set in set theory, the empty string is a 
    character string of length zero. 
    <dt>Finite-state stack machine 
    <dd>A "machine" that has discrete states in which it is said to exist at 
    each instant in time. As input to the machine is processed, the machine 
    moves from state to state as specified by the logic of the machine. In the 
    case of the parser, the input is the language being parsed, and the states 
    correspond to various stages in the grammar rules. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
    Parser Algorithm</a>. 
    <dt>Grouping 
    <dd>A language construct that is (in general) grammatically divisible; for 
    example, `expression' or `declaration' in C. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a>. 
    <dt>Infix operator 
    <dd>An arithmetic operator that is placed between the operands on which it 
    performs some operation. 
    <dt>Input stream 
    <dd>A continuous flow of data between devices or programs. 
    <dt>Language construct 
    <dd>One of the typical usage schemas of the language. For example, one of 
    the constructs of the C language is the <code>if</code> statement. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a>. 
    <dt>Left associativity 
    <dd>Operators having left associativity are analyzed from left to right: 
    <samp>`a+b+c'</samp> first computes <samp>`a+b'</samp> and then combines 
    with <samp>`c'</samp>. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC71">Operator 
    Precedence</a>. 
    <dt>Left recursion 
    <dd>A rule whose result symbol is also its first component symbol; for 
    example, <samp>`expseq1 : expseq1 ',' exp;'</samp>. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC42">Recursive 
    Rules</a>. 
    <dt>Left-to-right parsing 
    <dd>Parsing a sentence of a language by analyzing it token by token from 
    left to right. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
    Parser Algorithm</a>. 
    <dt>Lexical analyzer (scanner) 
    <dd>A function that reads an input stream and returns tokens one by one. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC61">The 
    Lexical Analyzer Function <code>yylex</code></a>. 
    <dt>Lexical tie-in 
    <dd>A flag, set by actions in the grammar rules, which alters the way tokens 
    are parsed. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC84">Lexical 
    Tie-ins</a>. 
    <dt>Look-ahead token 
    <dd>A token already read but not yet shifted. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC69">Look-Ahead 
    Tokens</a>. 
    <dt>LALR(1) 
    <dd>The class of context-free grammars that Bison (like most other parser 
    generators) can handle; a subset of LR(1). See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC79">Mysterious 
    Reduce/Reduce Conflicts</a>. 
    <dt>LR(1) 
    <dd>The class of context-free grammars in which at most one token of 
    look-ahead is needed to disambiguate the parsing of any piece of input. 
    <dt>Nonterminal symbol 
    <dd>A grammar symbol standing for a grammatical construct that can be 
    expressed through rules in terms of smaller constructs; in other words, a 
    construct that is not a token. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
    Terminal and Nonterminal</a>. 
    <dt>Parse error 
    <dd>An error encountered during parsing of an input stream due to invalid 
    syntax. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC81">Error 
    Recovery</a>. 
    <dt>Parser 
    <dd>A function that recognizes valid sentences of a language by analyzing 
    the syntax structure of a set of tokens passed to it from a lexical 
    analyzer. 
    <dt>Postfix operator 
    <dd>An arithmetic operator that is placed after the operands upon which it 
    performs some operation. 
    <dt>Reduction 
    <dd>Replacing a string of nonterminals and/or terminals with a single 
    nonterminal, according to a grammar rule. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
    Parser Algorithm</a>. 
    <dt>Reentrant 
    <dd>A reentrant subprogram is a subprogram which can be in invoked any 
    number of times in parallel, without interference between the various 
    invocations. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC56">A Pure 
    (Reentrant) Parser</a>. 
    <dt>Reverse polish notation 
    <dd>A language in which all operators are postfix operators. 
    <dt>Right recursion 
    <dd>A rule whose result symbol is also its last component symbol; for 
    example, <samp>`expseq1: exp ',' expseq1;'</samp>. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC42">Recursive 
    Rules</a>. 
    <dt>Semantics 
    <dd>In computer languages, the semantics are specified by the actions taken 
    for each instance of the language, i.e., the meaning of each statement. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC43">Defining 
    Language Semantics</a>. 
    <dt>Shift 
    <dd>A parser is said to shift when it makes the choice of analyzing further 
    input from the stream rather than reducing immediately some 
    already-recognized rule. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC68">The Bison 
    Parser Algorithm</a>. 
    <dt>Single-character literal 
    <dd>A single character that is recognized and interpreted as is. See section 
    <a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC9">From 
    Formal Rules to Bison Input</a>. 
    <dt>Start symbol 
    <dd>The nonterminal symbol that stands for a complete valid utterance in the 
    language being parsed. The start symbol is usually listed as the first 
    nonterminal symbol in a language specification. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC55">The 
    Start-Symbol</a>. 
    <dt>Symbol table 
    <dd>A data structure where symbol names and associated data are stored 
    during parsing to allow for recognition and use of existing information in 
    repeated uses of a symbol. See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC29">Multi-Function 
    Calculator: <code>mfcalc</code></a>. 
    <dt>Token 
    <dd>A basic, grammatically indivisible unit of a language. The symbol that 
    describes a token in the grammar is a terminal symbol. The input of the 
    Bison parser is a stream of tokens which comes from the lexical analyzer. 
    See section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC40">Symbols, 
    Terminal and Nonterminal</a>. 
    <dt>Terminal symbol 
    <dd>A grammar symbol that has no rules in the grammar and therefore is 
    grammatically indivisible. The piece of text it represents is a token. See 
    section <a 
    href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#SEC8">Languages 
    and Context-Free Grammars</a>. </dd></dl>
  <p>
  <h1><a name=SEC93 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#TOC93">Index</a></h1>
  <p>Jump to: <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#$">$</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#%">%</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#@">@</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#a">a</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#b">b</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#c">c</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#d">d</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#e">e</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#f">f</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#g">g</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#i">i</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#l">l</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#m">m</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#n">n</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#o">o</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#p">p</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#r">r</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#s">s</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#t">t</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#u">u</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#v">v</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#w">w</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#y">y</a> - <a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#|">|</a> 
  <p>
  <h2><a name=$>$</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX80">$$</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX81">$<var>n</var></a> 
  </li></dir>
  <h2><a name=%>%</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX105">%expect</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX155">%left</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX157">%nonassoc</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX162">%prec</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX112">%pure_parser</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX156">%right</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX109">%start</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX91">%token</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX100">%type</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX97">%union</a> 
  </li></dir>
  <h2><a name=@>@</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX139">@<var>n</var></a> 
  </li></dir>
  <h2><a name=a>a</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX79">action</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX83">action data 
  types</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX135">action 
  features summary</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX85">actions in 
  mid-rule</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX17">actions, 
  semantic</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX56">additional 
  C code section</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX141">algorithm 
  of parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX154">associativity</a> 
  </li></dir>
  <h2><a name=b>b</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX5">Backus-Naur 
  form</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX113">Bison 
  declaration summary</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX88">Bison 
  declarations</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX52">Bison 
  declarations (introduction)</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX11">Bison 
  grammar</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX189">Bison 
  invocation</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX18">Bison 
  parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX140">Bison 
  parser algorithm</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX193">Bison 
  symbols, table of</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX19">Bison 
  utility</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX4">BNF</a> 
  </li></dir>
  <h2><a name=c>c</a></h2>
  <dir>
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX57">C 
  code, section for additional</a> 
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX50">C 
  declarations section</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX116">C-language 
  interface</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX42"><code>calc</code></a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX43">calculator, 
  infix notation</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX47">calculator, 
  multi-function</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX33">calculator, 
  simple</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX62">character 
  token</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX40">compiling 
  the parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX148">conflicts</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX167">conflicts, 
  reduce/reduce</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX104">conflicts, 
  suppressing warnings of</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX158">context-dependent 
  precedence</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX2">context-free 
  grammar</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX36">controlling 
  function</a> </li></dir>
  <h2><a name=d>d</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX150">dangling 
  <code>else</code></a> 
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX84">data 
  types in actions</a> 
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX77">data 
  types of semantic values</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX185">debugging</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX114">declaration 
  summary</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX87">declarations, 
  Bison</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX53">declarations, 
  Bison (introduction)</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX51">declarations, 
  C</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX93">declaring 
  operator precedence</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX106">declaring 
  the start symbol</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX89">declaring 
  token type names</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX95">declaring 
  value types</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX98">declaring 
  value types, nonterminals</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX82">default 
  action</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX78">default 
  data type</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX174">default 
  stack limit</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX108">default 
  start symbol</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX73">defining 
  language semantics</a> </li></dir>
  <h2><a name=e>e</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX151"><code>else</code>, 
  dangling</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX178">error</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX176">error 
  recovery</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX44">error 
  recovery, simple</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX128">error 
  reporting function</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX38">error 
  reporting routine</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX29">examples, 
  simple</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX49">exercises</a> 
  </li></dir>
  <h2><a name=f>f</a></h2>
  <dir>
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX25">file 
  format</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX163">finite-state 
  machine</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX13">formal 
  grammar</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX26">format of 
  grammar file</a> </li></dir>
  <h2><a name=g>g</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX195">glossary</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX24">grammar 
  file</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX66">grammar 
  rule syntax</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX54">grammar 
  rules section</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX12">grammar, 
  Bison</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX3">grammar, 
  context-free</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX9">grouping, 
  syntactic</a> </li></dir>
  <h2><a name=i>i</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX41">infix 
  notation calculator</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX117">interface</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX1">introduction</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX188">invoking 
  Bison</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX191">invoking 
  Bison under VMS</a> </li></dir>
  <h2><a name=l>l</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX169">LALR(1)</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX74">language 
  semantics, defining</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX27">layout of 
  Bison grammar</a> 
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX70">left 
  recursion</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX122">lexical 
  analyzer</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX20">lexical 
  analyzer, purpose</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX35">lexical 
  analyzer, writing</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX182">lexical 
  tie-in</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX63">literal 
  token</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX146">look-ahead 
  token</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX168">LR(1)</a> 
  </li></dir>
  <h2><a name=m>m</a></h2>
  <dir>
  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX37">main 
  function in simple example</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX46"><code>mfcalc</code></a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX86">mid-rule 
  actions</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX45">multi-function 
  calculator</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX72">mutual 
  recursion</a> </li></dir>
  <h2><a name=n>n</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX58">nonterminal 
  symbol</a> </li></dir>
  <h2><a name=o>o</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX152">operator 
  precedence</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX94">operator 
  precedence, declaring</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX190">options 
  for invoking Bison</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX172">overflow 
  of parser stack</a> </li></dir>
  <h2><a name=p>p</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX130">parse 
  error</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX21">parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX144">parser 
  stack</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX171">parser 
  stack overflow</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX164">parser 
  state</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX31">polish 
  notation calculator</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX92">precedence 
  declarations</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX153">precedence 
  of operators</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX160">precedence, 
  context-dependent</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX161">precedence, 
  unary operator</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX102">preventing 
  warnings about conflicts</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX111">pure 
  parser</a> </li></dir>
  <h2><a name=r>r</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX177">recovery 
  from errors</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX69">recursive 
  rule</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX166">reduce/reduce 
  conflict</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX143">reduction</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX110">reentrant 
  parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX30">reverse 
  polish notation</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX71">right 
  recursion</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX32"><code>rpcalc</code></a> 

  <li><a href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX65">rule 
  syntax</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX55">rules 
  section for grammar</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX39">running 
  Bison (introduction)</a> </li></dir>
  <h2><a name=s>s</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX16">semantic 
  actions</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX14">semantic 
  value</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX75">semantic 
  value type</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX149">shift/reduce 
  conflicts</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX142">shifting</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX28">simple 
  examples</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX64">single-character 
  literal</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX170">stack 
  overflow</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX145">stack, 
  parser</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX22">stages in 
  using Bison</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX10">start 
  symbol</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX107">start 
  symbol, declaring</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX165">state (of 
  parser)</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX134">summary, 
  action features</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX115">summary, 
  Bison declaration</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX101">suppressing 
  conflict warnings</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX61">symbol</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX48">symbol 
  table example</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX6">symbols 
  (abstract)</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX194">symbols in 
  Bison, table of</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX8">syntactic 
  grouping</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX131">syntax 
  error</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX67">syntax of 
  grammar rules</a> </li></dir>
  <h2><a name=t>t</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX59">terminal 
  symbol</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX7">token</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX60">token 
  type</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX90">token type 
  names, declaring</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX186">tracing 
  the parser</a> </li></dir>
  <h2><a name=u>u</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX159">unary 
  operator precedence</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX23">using 
  Bison</a> </li></dir>
  <h2><a name=v>v</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX76">value type, 
  semantic</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX96">value 
  types, declaring</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX99">value 
  types, nonterminals, declaring</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX15">value, 
  semantic</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX192">VMS</a> 
  </li></dir>
  <h2><a name=w>w</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX103">warnings, 
  preventing</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX34">writing a 
  lexical analyzer</a> </li></dir>
  <h2><a name=y>y</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX120">YYABORT</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX119">YYACCEPT</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX136">YYBACKUP</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX147">yychar</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX180">yyclearin</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX183">YYDEBUG</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX184">yydebug</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX137">YYEMPTY</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX179">yyerrok</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX129">yyerror</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX138">YYERROR</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX132">YYERROR_VERBOSE</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX175">YYINITDEPTH</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX121">yylex</a> 
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX127">YYLEX_PARAM</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX124">yylloc</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX125">YYLTYPE</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX123">yylval</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX173">YYMAXDEPTH</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX133">yynerrs</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX118">yyparse</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX126">YYPARSE_PARAM</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX187">YYPRINT</a> 

  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX181">YYRECOVERING</a> 
  </li></dir>
  <h2><a name=|>|</a></h2>
  <dir>
  <li><a 
  href="http://www.monmouth.com/~wstreett/lex-yacc/bison.html#IDX68">|</a> 
  </li></dir>
  <p>
  <hr>

  <p>This document was generated on 2 October 1998 using the <a 
  href="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</a> translator version 
  1.52.</p></UL></body></html>
